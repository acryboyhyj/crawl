// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: spider.proto

#ifndef PROTOBUF_INCLUDED_spider_2eproto
#define PROTOBUF_INCLUDED_spider_2eproto

#include <limits>
#include <string>

#include <google/protobuf/stubs/common.h>
#if GOOGLE_PROTOBUF_VERSION < 3006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_spider_2eproto

// Internal implementation detail -- do not use these members.
struct TableStruct_spider_2eproto {
  static const ::google::protobuf::internal::ParseTableField entries[]
    GOOGLE_PROTOBUF_ATTRIBUTE_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[]
    GOOGLE_PROTOBUF_ATTRIBUTE_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::ParseTable schema[18]
    GOOGLE_PROTOBUF_ATTRIBUTE_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors_spider_2eproto();
namespace spiderproto {
class BasicTask;
class BasicTaskDefaultTypeInternal;
extern BasicTaskDefaultTypeInternal _BasicTask_default_instance_;
class CrawlDoc;
class CrawlDocDefaultTypeInternal;
extern CrawlDocDefaultTypeInternal _CrawlDoc_default_instance_;
class CrawlDocs;
class CrawlDocsDefaultTypeInternal;
extern CrawlDocsDefaultTypeInternal _CrawlDocs_default_instance_;
class CrawlStats;
class CrawlStatsDefaultTypeInternal;
extern CrawlStatsDefaultTypeInternal _CrawlStats_default_instance_;
class CrawlUrl;
class CrawlUrlDefaultTypeInternal;
extern CrawlUrlDefaultTypeInternal _CrawlUrl_default_instance_;
class CrawlUrlList;
class CrawlUrlListDefaultTypeInternal;
extern CrawlUrlListDefaultTypeInternal _CrawlUrlList_default_instance_;
class CrawledTask;
class CrawledTaskDefaultTypeInternal;
extern CrawledTaskDefaultTypeInternal _CrawledTask_default_instance_;
class CrawlingTask;
class CrawlingTaskDefaultTypeInternal;
extern CrawlingTaskDefaultTypeInternal _CrawlingTask_default_instance_;
class Empty;
class EmptyDefaultTypeInternal;
extern EmptyDefaultTypeInternal _Empty_default_instance_;
class Feature;
class FeatureDefaultTypeInternal;
extern FeatureDefaultTypeInternal _Feature_default_instance_;
class Fetcher;
class FetcherDefaultTypeInternal;
extern FetcherDefaultTypeInternal _Fetcher_default_instance_;
class LinkRule;
class LinkRuleDefaultTypeInternal;
extern LinkRuleDefaultTypeInternal _LinkRule_default_instance_;
class LinkRuleList;
class LinkRuleListDefaultTypeInternal;
extern LinkRuleListDefaultTypeInternal _LinkRuleList_default_instance_;
class Runtime;
class RuntimeDefaultTypeInternal;
extern RuntimeDefaultTypeInternal _Runtime_default_instance_;
class Segment;
class SegmentDefaultTypeInternal;
extern SegmentDefaultTypeInternal _Segment_default_instance_;
class SegmentList;
class SegmentListDefaultTypeInternal;
extern SegmentListDefaultTypeInternal _SegmentList_default_instance_;
class Storage;
class StorageDefaultTypeInternal;
extern StorageDefaultTypeInternal _Storage_default_instance_;
class TaskResponse;
class TaskResponseDefaultTypeInternal;
extern TaskResponseDefaultTypeInternal _TaskResponse_default_instance_;
}  // namespace spiderproto
namespace google {
namespace protobuf {
template<> ::spiderproto::BasicTask* Arena::CreateMaybeMessage<::spiderproto::BasicTask>(Arena*);
template<> ::spiderproto::CrawlDoc* Arena::CreateMaybeMessage<::spiderproto::CrawlDoc>(Arena*);
template<> ::spiderproto::CrawlDocs* Arena::CreateMaybeMessage<::spiderproto::CrawlDocs>(Arena*);
template<> ::spiderproto::CrawlStats* Arena::CreateMaybeMessage<::spiderproto::CrawlStats>(Arena*);
template<> ::spiderproto::CrawlUrl* Arena::CreateMaybeMessage<::spiderproto::CrawlUrl>(Arena*);
template<> ::spiderproto::CrawlUrlList* Arena::CreateMaybeMessage<::spiderproto::CrawlUrlList>(Arena*);
template<> ::spiderproto::CrawledTask* Arena::CreateMaybeMessage<::spiderproto::CrawledTask>(Arena*);
template<> ::spiderproto::CrawlingTask* Arena::CreateMaybeMessage<::spiderproto::CrawlingTask>(Arena*);
template<> ::spiderproto::Empty* Arena::CreateMaybeMessage<::spiderproto::Empty>(Arena*);
template<> ::spiderproto::Feature* Arena::CreateMaybeMessage<::spiderproto::Feature>(Arena*);
template<> ::spiderproto::Fetcher* Arena::CreateMaybeMessage<::spiderproto::Fetcher>(Arena*);
template<> ::spiderproto::LinkRule* Arena::CreateMaybeMessage<::spiderproto::LinkRule>(Arena*);
template<> ::spiderproto::LinkRuleList* Arena::CreateMaybeMessage<::spiderproto::LinkRuleList>(Arena*);
template<> ::spiderproto::Runtime* Arena::CreateMaybeMessage<::spiderproto::Runtime>(Arena*);
template<> ::spiderproto::Segment* Arena::CreateMaybeMessage<::spiderproto::Segment>(Arena*);
template<> ::spiderproto::SegmentList* Arena::CreateMaybeMessage<::spiderproto::SegmentList>(Arena*);
template<> ::spiderproto::Storage* Arena::CreateMaybeMessage<::spiderproto::Storage>(Arena*);
template<> ::spiderproto::TaskResponse* Arena::CreateMaybeMessage<::spiderproto::TaskResponse>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace spiderproto {

enum Storage_StorageType {
  Storage_StorageType_STORAGE_HDFS = 0,
  Storage_StorageType_STORAGE_MQ = 1,
  Storage_StorageType_Storage_StorageType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  Storage_StorageType_Storage_StorageType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool Storage_StorageType_IsValid(int value);
const Storage_StorageType Storage_StorageType_StorageType_MIN = Storage_StorageType_STORAGE_HDFS;
const Storage_StorageType Storage_StorageType_StorageType_MAX = Storage_StorageType_STORAGE_MQ;
const int Storage_StorageType_StorageType_ARRAYSIZE = Storage_StorageType_StorageType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Storage_StorageType_descriptor();
inline const ::std::string& Storage_StorageType_Name(Storage_StorageType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Storage_StorageType_descriptor(), value);
}
inline bool Storage_StorageType_Parse(
    const ::std::string& name, Storage_StorageType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Storage_StorageType>(
    Storage_StorageType_descriptor(), name, value);
}
enum UrlLevel {
  LEVEL_LIST = 0,
  LEVEL_CONTENT = 1,
  UrlLevel_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  UrlLevel_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool UrlLevel_IsValid(int value);
const UrlLevel UrlLevel_MIN = LEVEL_LIST;
const UrlLevel UrlLevel_MAX = LEVEL_CONTENT;
const int UrlLevel_ARRAYSIZE = UrlLevel_MAX + 1;

const ::google::protobuf::EnumDescriptor* UrlLevel_descriptor();
inline const ::std::string& UrlLevel_Name(UrlLevel value) {
  return ::google::protobuf::internal::NameOfEnum(
    UrlLevel_descriptor(), value);
}
inline bool UrlLevel_Parse(
    const ::std::string& name, UrlLevel* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UrlLevel>(
    UrlLevel_descriptor(), name, value);
}
// ===================================================================

class CrawlUrl : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:spiderproto.CrawlUrl) */ {
 public:
  CrawlUrl();
  virtual ~CrawlUrl();

  CrawlUrl(const CrawlUrl& from);

  inline CrawlUrl& operator=(const CrawlUrl& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CrawlUrl(CrawlUrl&& from) noexcept
    : CrawlUrl() {
    *this = ::std::move(from);
  }

  inline CrawlUrl& operator=(CrawlUrl&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CrawlUrl& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CrawlUrl* internal_default_instance() {
    return reinterpret_cast<const CrawlUrl*>(
               &_CrawlUrl_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(CrawlUrl* other);
  friend void swap(CrawlUrl& a, CrawlUrl& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CrawlUrl* New() const final {
    return CreateMaybeMessage<CrawlUrl>(NULL);
  }

  CrawlUrl* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CrawlUrl>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CrawlUrl& from);
  void MergeFrom(const CrawlUrl& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CrawlUrl* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes url = 1;
  void clear_url();
  static const int kUrlFieldNumber = 1;
  const ::std::string& url() const;
  void set_url(const ::std::string& value);
  #if LANG_CXX11
  void set_url(::std::string&& value);
  #endif
  void set_url(const char* value);
  void set_url(const void* value, size_t size);
  ::std::string* mutable_url();
  ::std::string* release_url();
  void set_allocated_url(::std::string* url);

  // .spiderproto.UrlLevel level = 2;
  void clear_level();
  static const int kLevelFieldNumber = 2;
  ::spiderproto::UrlLevel level() const;
  void set_level(::spiderproto::UrlLevel value);

  // bool usedable = 3;
  void clear_usedable();
  static const int kUsedableFieldNumber = 3;
  bool usedable() const;
  void set_usedable(bool value);

  // @@protoc_insertion_point(class_scope:spiderproto.CrawlUrl)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr url_;
  int level_;
  bool usedable_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_spider_2eproto;
};
// -------------------------------------------------------------------

class Feature : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:spiderproto.Feature) */ {
 public:
  Feature();
  virtual ~Feature();

  Feature(const Feature& from);

  inline Feature& operator=(const Feature& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Feature(Feature&& from) noexcept
    : Feature() {
    *this = ::std::move(from);
  }

  inline Feature& operator=(Feature&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Feature& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Feature* internal_default_instance() {
    return reinterpret_cast<const Feature*>(
               &_Feature_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(Feature* other);
  friend void swap(Feature& a, Feature& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Feature* New() const final {
    return CreateMaybeMessage<Feature>(NULL);
  }

  Feature* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Feature>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Feature& from);
  void MergeFrom(const Feature& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Feature* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool dup_ignore = 1;
  void clear_dup_ignore();
  static const int kDupIgnoreFieldNumber = 1;
  bool dup_ignore() const;
  void set_dup_ignore(bool value);

  // bool testing = 2;
  void clear_testing();
  static const int kTestingFieldNumber = 2;
  bool testing() const;
  void set_testing(bool value);

  // bool period = 3;
  void clear_period();
  static const int kPeriodFieldNumber = 3;
  bool period() const;
  void set_period(bool value);

  // int32 interval = 4;
  void clear_interval();
  static const int kIntervalFieldNumber = 4;
  ::google::protobuf::int32 interval() const;
  void set_interval(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:spiderproto.Feature)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool dup_ignore_;
  bool testing_;
  bool period_;
  ::google::protobuf::int32 interval_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_spider_2eproto;
};
// -------------------------------------------------------------------

class LinkRule : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:spiderproto.LinkRule) */ {
 public:
  LinkRule();
  virtual ~LinkRule();

  LinkRule(const LinkRule& from);

  inline LinkRule& operator=(const LinkRule& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LinkRule(LinkRule&& from) noexcept
    : LinkRule() {
    *this = ::std::move(from);
  }

  inline LinkRule& operator=(LinkRule&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const LinkRule& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LinkRule* internal_default_instance() {
    return reinterpret_cast<const LinkRule*>(
               &_LinkRule_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(LinkRule* other);
  friend void swap(LinkRule& a, LinkRule& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LinkRule* New() const final {
    return CreateMaybeMessage<LinkRule>(NULL);
  }

  LinkRule* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LinkRule>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LinkRule& from);
  void MergeFrom(const LinkRule& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LinkRule* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes rules = 2;
  int rules_size() const;
  void clear_rules();
  static const int kRulesFieldNumber = 2;
  const ::std::string& rules(int index) const;
  ::std::string* mutable_rules(int index);
  void set_rules(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_rules(int index, ::std::string&& value);
  #endif
  void set_rules(int index, const char* value);
  void set_rules(int index, const void* value, size_t size);
  ::std::string* add_rules();
  void add_rules(const ::std::string& value);
  #if LANG_CXX11
  void add_rules(::std::string&& value);
  #endif
  void add_rules(const char* value);
  void add_rules(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField<::std::string>& rules() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* mutable_rules();

  // .spiderproto.UrlLevel in_level = 1;
  void clear_in_level();
  static const int kInLevelFieldNumber = 1;
  ::spiderproto::UrlLevel in_level() const;
  void set_in_level(::spiderproto::UrlLevel value);

  // .spiderproto.UrlLevel out_level = 3;
  void clear_out_level();
  static const int kOutLevelFieldNumber = 3;
  ::spiderproto::UrlLevel out_level() const;
  void set_out_level(::spiderproto::UrlLevel value);

  // @@protoc_insertion_point(class_scope:spiderproto.LinkRule)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField<::std::string> rules_;
  int in_level_;
  int out_level_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_spider_2eproto;
};
// -------------------------------------------------------------------

class Storage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:spiderproto.Storage) */ {
 public:
  Storage();
  virtual ~Storage();

  Storage(const Storage& from);

  inline Storage& operator=(const Storage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Storage(Storage&& from) noexcept
    : Storage() {
    *this = ::std::move(from);
  }

  inline Storage& operator=(Storage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Storage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Storage* internal_default_instance() {
    return reinterpret_cast<const Storage*>(
               &_Storage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(Storage* other);
  friend void swap(Storage& a, Storage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Storage* New() const final {
    return CreateMaybeMessage<Storage>(NULL);
  }

  Storage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Storage>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Storage& from);
  void MergeFrom(const Storage& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Storage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Storage_StorageType StorageType;
  static const StorageType STORAGE_HDFS =
    Storage_StorageType_STORAGE_HDFS;
  static const StorageType STORAGE_MQ =
    Storage_StorageType_STORAGE_MQ;
  static inline bool StorageType_IsValid(int value) {
    return Storage_StorageType_IsValid(value);
  }
  static const StorageType StorageType_MIN =
    Storage_StorageType_StorageType_MIN;
  static const StorageType StorageType_MAX =
    Storage_StorageType_StorageType_MAX;
  static const int StorageType_ARRAYSIZE =
    Storage_StorageType_StorageType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  StorageType_descriptor() {
    return Storage_StorageType_descriptor();
  }
  static inline const ::std::string& StorageType_Name(StorageType value) {
    return Storage_StorageType_Name(value);
  }
  static inline bool StorageType_Parse(const ::std::string& name,
      StorageType* value) {
    return Storage_StorageType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // bytes dest = 2;
  void clear_dest();
  static const int kDestFieldNumber = 2;
  const ::std::string& dest() const;
  void set_dest(const ::std::string& value);
  #if LANG_CXX11
  void set_dest(::std::string&& value);
  #endif
  void set_dest(const char* value);
  void set_dest(const void* value, size_t size);
  ::std::string* mutable_dest();
  ::std::string* release_dest();
  void set_allocated_dest(::std::string* dest);

  // bytes attachment = 3;
  void clear_attachment();
  static const int kAttachmentFieldNumber = 3;
  const ::std::string& attachment() const;
  void set_attachment(const ::std::string& value);
  #if LANG_CXX11
  void set_attachment(::std::string&& value);
  #endif
  void set_attachment(const char* value);
  void set_attachment(const void* value, size_t size);
  ::std::string* mutable_attachment();
  ::std::string* release_attachment();
  void set_allocated_attachment(::std::string* attachment);

  // .spiderproto.Storage.StorageType store_type = 1;
  void clear_store_type();
  static const int kStoreTypeFieldNumber = 1;
  ::spiderproto::Storage_StorageType store_type() const;
  void set_store_type(::spiderproto::Storage_StorageType value);

  // @@protoc_insertion_point(class_scope:spiderproto.Storage)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr dest_;
  ::google::protobuf::internal::ArenaStringPtr attachment_;
  int store_type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_spider_2eproto;
};
// -------------------------------------------------------------------

class Runtime : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:spiderproto.Runtime) */ {
 public:
  Runtime();
  virtual ~Runtime();

  Runtime(const Runtime& from);

  inline Runtime& operator=(const Runtime& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Runtime(Runtime&& from) noexcept
    : Runtime() {
    *this = ::std::move(from);
  }

  inline Runtime& operator=(Runtime&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Runtime& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Runtime* internal_default_instance() {
    return reinterpret_cast<const Runtime*>(
               &_Runtime_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(Runtime* other);
  friend void swap(Runtime& a, Runtime& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Runtime* New() const final {
    return CreateMaybeMessage<Runtime>(NULL);
  }

  Runtime* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Runtime>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Runtime& from);
  void MergeFrom(const Runtime& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Runtime* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes allow_fetchers = 3;
  int allow_fetchers_size() const;
  void clear_allow_fetchers();
  static const int kAllowFetchersFieldNumber = 3;
  const ::std::string& allow_fetchers(int index) const;
  ::std::string* mutable_allow_fetchers(int index);
  void set_allow_fetchers(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_allow_fetchers(int index, ::std::string&& value);
  #endif
  void set_allow_fetchers(int index, const char* value);
  void set_allow_fetchers(int index, const void* value, size_t size);
  ::std::string* add_allow_fetchers();
  void add_allow_fetchers(const ::std::string& value);
  #if LANG_CXX11
  void add_allow_fetchers(::std::string&& value);
  #endif
  void add_allow_fetchers(const char* value);
  void add_allow_fetchers(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField<::std::string>& allow_fetchers() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* mutable_allow_fetchers();

  // repeated bytes deny_fetchers = 4;
  int deny_fetchers_size() const;
  void clear_deny_fetchers();
  static const int kDenyFetchersFieldNumber = 4;
  const ::std::string& deny_fetchers(int index) const;
  ::std::string* mutable_deny_fetchers(int index);
  void set_deny_fetchers(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_deny_fetchers(int index, ::std::string&& value);
  #endif
  void set_deny_fetchers(int index, const char* value);
  void set_deny_fetchers(int index, const void* value, size_t size);
  ::std::string* add_deny_fetchers();
  void add_deny_fetchers(const ::std::string& value);
  #if LANG_CXX11
  void add_deny_fetchers(::std::string&& value);
  #endif
  void add_deny_fetchers(const char* value);
  void add_deny_fetchers(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField<::std::string>& deny_fetchers() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* mutable_deny_fetchers();

  // float download_delay = 1;
  void clear_download_delay();
  static const int kDownloadDelayFieldNumber = 1;
  float download_delay() const;
  void set_download_delay(float value);

  // int32 concurrent_reqs = 2;
  void clear_concurrent_reqs();
  static const int kConcurrentReqsFieldNumber = 2;
  ::google::protobuf::int32 concurrent_reqs() const;
  void set_concurrent_reqs(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:spiderproto.Runtime)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField<::std::string> allow_fetchers_;
  ::google::protobuf::RepeatedPtrField<::std::string> deny_fetchers_;
  float download_delay_;
  ::google::protobuf::int32 concurrent_reqs_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_spider_2eproto;
};
// -------------------------------------------------------------------

class BasicTask : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:spiderproto.BasicTask) */ {
 public:
  BasicTask();
  virtual ~BasicTask();

  BasicTask(const BasicTask& from);

  inline BasicTask& operator=(const BasicTask& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BasicTask(BasicTask&& from) noexcept
    : BasicTask() {
    *this = ::std::move(from);
  }

  inline BasicTask& operator=(BasicTask&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const BasicTask& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BasicTask* internal_default_instance() {
    return reinterpret_cast<const BasicTask*>(
               &_BasicTask_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(BasicTask* other);
  friend void swap(BasicTask& a, BasicTask& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BasicTask* New() const final {
    return CreateMaybeMessage<BasicTask>(NULL);
  }

  BasicTask* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BasicTask>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BasicTask& from);
  void MergeFrom(const BasicTask& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BasicTask* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes taskid = 1;
  void clear_taskid();
  static const int kTaskidFieldNumber = 1;
  const ::std::string& taskid() const;
  void set_taskid(const ::std::string& value);
  #if LANG_CXX11
  void set_taskid(::std::string&& value);
  #endif
  void set_taskid(const char* value);
  void set_taskid(const void* value, size_t size);
  ::std::string* mutable_taskid();
  ::std::string* release_taskid();
  void set_allocated_taskid(::std::string* taskid);

  // bytes name = 2;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const void* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // bytes user = 3;
  void clear_user();
  static const int kUserFieldNumber = 3;
  const ::std::string& user() const;
  void set_user(const ::std::string& value);
  #if LANG_CXX11
  void set_user(::std::string&& value);
  #endif
  void set_user(const char* value);
  void set_user(const void* value, size_t size);
  ::std::string* mutable_user();
  ::std::string* release_user();
  void set_allocated_user(::std::string* user);

  // .spiderproto.CrawlUrlList crawl_list = 4;
  bool has_crawl_list() const;
  void clear_crawl_list();
  static const int kCrawlListFieldNumber = 4;
  const ::spiderproto::CrawlUrlList& crawl_list() const;
  ::spiderproto::CrawlUrlList* release_crawl_list();
  ::spiderproto::CrawlUrlList* mutable_crawl_list();
  void set_allocated_crawl_list(::spiderproto::CrawlUrlList* crawl_list);

  // .spiderproto.Feature feature = 5;
  bool has_feature() const;
  void clear_feature();
  static const int kFeatureFieldNumber = 5;
  const ::spiderproto::Feature& feature() const;
  ::spiderproto::Feature* release_feature();
  ::spiderproto::Feature* mutable_feature();
  void set_allocated_feature(::spiderproto::Feature* feature);

  // .spiderproto.LinkRuleList rule_list = 6;
  bool has_rule_list() const;
  void clear_rule_list();
  static const int kRuleListFieldNumber = 6;
  const ::spiderproto::LinkRuleList& rule_list() const;
  ::spiderproto::LinkRuleList* release_rule_list();
  ::spiderproto::LinkRuleList* mutable_rule_list();
  void set_allocated_rule_list(::spiderproto::LinkRuleList* rule_list);

  // .spiderproto.Storage storage = 7;
  bool has_storage() const;
  void clear_storage();
  static const int kStorageFieldNumber = 7;
  const ::spiderproto::Storage& storage() const;
  ::spiderproto::Storage* release_storage();
  ::spiderproto::Storage* mutable_storage();
  void set_allocated_storage(::spiderproto::Storage* storage);

  // .spiderproto.Runtime runtime = 8;
  bool has_runtime() const;
  void clear_runtime();
  static const int kRuntimeFieldNumber = 8;
  const ::spiderproto::Runtime& runtime() const;
  ::spiderproto::Runtime* release_runtime();
  ::spiderproto::Runtime* mutable_runtime();
  void set_allocated_runtime(::spiderproto::Runtime* runtime);

  // @@protoc_insertion_point(class_scope:spiderproto.BasicTask)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr taskid_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr user_;
  ::spiderproto::CrawlUrlList* crawl_list_;
  ::spiderproto::Feature* feature_;
  ::spiderproto::LinkRuleList* rule_list_;
  ::spiderproto::Storage* storage_;
  ::spiderproto::Runtime* runtime_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_spider_2eproto;
};
// -------------------------------------------------------------------

class CrawlUrlList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:spiderproto.CrawlUrlList) */ {
 public:
  CrawlUrlList();
  virtual ~CrawlUrlList();

  CrawlUrlList(const CrawlUrlList& from);

  inline CrawlUrlList& operator=(const CrawlUrlList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CrawlUrlList(CrawlUrlList&& from) noexcept
    : CrawlUrlList() {
    *this = ::std::move(from);
  }

  inline CrawlUrlList& operator=(CrawlUrlList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CrawlUrlList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CrawlUrlList* internal_default_instance() {
    return reinterpret_cast<const CrawlUrlList*>(
               &_CrawlUrlList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(CrawlUrlList* other);
  friend void swap(CrawlUrlList& a, CrawlUrlList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CrawlUrlList* New() const final {
    return CreateMaybeMessage<CrawlUrlList>(NULL);
  }

  CrawlUrlList* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CrawlUrlList>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CrawlUrlList& from);
  void MergeFrom(const CrawlUrlList& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CrawlUrlList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .spiderproto.CrawlUrl crawl_urls = 1;
  int crawl_urls_size() const;
  void clear_crawl_urls();
  static const int kCrawlUrlsFieldNumber = 1;
  ::spiderproto::CrawlUrl* mutable_crawl_urls(int index);
  ::google::protobuf::RepeatedPtrField< ::spiderproto::CrawlUrl >*
      mutable_crawl_urls();
  const ::spiderproto::CrawlUrl& crawl_urls(int index) const;
  ::spiderproto::CrawlUrl* add_crawl_urls();
  const ::google::protobuf::RepeatedPtrField< ::spiderproto::CrawlUrl >&
      crawl_urls() const;

  // @@protoc_insertion_point(class_scope:spiderproto.CrawlUrlList)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::spiderproto::CrawlUrl > crawl_urls_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_spider_2eproto;
};
// -------------------------------------------------------------------

class LinkRuleList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:spiderproto.LinkRuleList) */ {
 public:
  LinkRuleList();
  virtual ~LinkRuleList();

  LinkRuleList(const LinkRuleList& from);

  inline LinkRuleList& operator=(const LinkRuleList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LinkRuleList(LinkRuleList&& from) noexcept
    : LinkRuleList() {
    *this = ::std::move(from);
  }

  inline LinkRuleList& operator=(LinkRuleList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const LinkRuleList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LinkRuleList* internal_default_instance() {
    return reinterpret_cast<const LinkRuleList*>(
               &_LinkRuleList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(LinkRuleList* other);
  friend void swap(LinkRuleList& a, LinkRuleList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LinkRuleList* New() const final {
    return CreateMaybeMessage<LinkRuleList>(NULL);
  }

  LinkRuleList* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LinkRuleList>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LinkRuleList& from);
  void MergeFrom(const LinkRuleList& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LinkRuleList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .spiderproto.LinkRule rules = 1;
  int rules_size() const;
  void clear_rules();
  static const int kRulesFieldNumber = 1;
  ::spiderproto::LinkRule* mutable_rules(int index);
  ::google::protobuf::RepeatedPtrField< ::spiderproto::LinkRule >*
      mutable_rules();
  const ::spiderproto::LinkRule& rules(int index) const;
  ::spiderproto::LinkRule* add_rules();
  const ::google::protobuf::RepeatedPtrField< ::spiderproto::LinkRule >&
      rules() const;

  // @@protoc_insertion_point(class_scope:spiderproto.LinkRuleList)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::spiderproto::LinkRule > rules_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_spider_2eproto;
};
// -------------------------------------------------------------------

class CrawlingTask : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:spiderproto.CrawlingTask) */ {
 public:
  CrawlingTask();
  virtual ~CrawlingTask();

  CrawlingTask(const CrawlingTask& from);

  inline CrawlingTask& operator=(const CrawlingTask& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CrawlingTask(CrawlingTask&& from) noexcept
    : CrawlingTask() {
    *this = ::std::move(from);
  }

  inline CrawlingTask& operator=(CrawlingTask&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CrawlingTask& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CrawlingTask* internal_default_instance() {
    return reinterpret_cast<const CrawlingTask*>(
               &_CrawlingTask_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(CrawlingTask* other);
  friend void swap(CrawlingTask& a, CrawlingTask& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CrawlingTask* New() const final {
    return CreateMaybeMessage<CrawlingTask>(NULL);
  }

  CrawlingTask* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CrawlingTask>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CrawlingTask& from);
  void MergeFrom(const CrawlingTask& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CrawlingTask* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .spiderproto.CrawlUrl crawl_urls = 3;
  int crawl_urls_size() const;
  void clear_crawl_urls();
  static const int kCrawlUrlsFieldNumber = 3;
  ::spiderproto::CrawlUrl* mutable_crawl_urls(int index);
  ::google::protobuf::RepeatedPtrField< ::spiderproto::CrawlUrl >*
      mutable_crawl_urls();
  const ::spiderproto::CrawlUrl& crawl_urls(int index) const;
  ::spiderproto::CrawlUrl* add_crawl_urls();
  const ::google::protobuf::RepeatedPtrField< ::spiderproto::CrawlUrl >&
      crawl_urls() const;

  // repeated .spiderproto.LinkRule rules = 4;
  int rules_size() const;
  void clear_rules();
  static const int kRulesFieldNumber = 4;
  ::spiderproto::LinkRule* mutable_rules(int index);
  ::google::protobuf::RepeatedPtrField< ::spiderproto::LinkRule >*
      mutable_rules();
  const ::spiderproto::LinkRule& rules(int index) const;
  ::spiderproto::LinkRule* add_rules();
  const ::google::protobuf::RepeatedPtrField< ::spiderproto::LinkRule >&
      rules() const;

  // bytes taskid = 1;
  void clear_taskid();
  static const int kTaskidFieldNumber = 1;
  const ::std::string& taskid() const;
  void set_taskid(const ::std::string& value);
  #if LANG_CXX11
  void set_taskid(::std::string&& value);
  #endif
  void set_taskid(const char* value);
  void set_taskid(const void* value, size_t size);
  ::std::string* mutable_taskid();
  ::std::string* release_taskid();
  void set_allocated_taskid(::std::string* taskid);

  // bytes fetcher = 2;
  void clear_fetcher();
  static const int kFetcherFieldNumber = 2;
  const ::std::string& fetcher() const;
  void set_fetcher(const ::std::string& value);
  #if LANG_CXX11
  void set_fetcher(::std::string&& value);
  #endif
  void set_fetcher(const char* value);
  void set_fetcher(const void* value, size_t size);
  ::std::string* mutable_fetcher();
  ::std::string* release_fetcher();
  void set_allocated_fetcher(::std::string* fetcher);

  // .spiderproto.Storage storage = 5;
  bool has_storage() const;
  void clear_storage();
  static const int kStorageFieldNumber = 5;
  const ::spiderproto::Storage& storage() const;
  ::spiderproto::Storage* release_storage();
  ::spiderproto::Storage* mutable_storage();
  void set_allocated_storage(::spiderproto::Storage* storage);

  // @@protoc_insertion_point(class_scope:spiderproto.CrawlingTask)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::spiderproto::CrawlUrl > crawl_urls_;
  ::google::protobuf::RepeatedPtrField< ::spiderproto::LinkRule > rules_;
  ::google::protobuf::internal::ArenaStringPtr taskid_;
  ::google::protobuf::internal::ArenaStringPtr fetcher_;
  ::spiderproto::Storage* storage_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_spider_2eproto;
};
// -------------------------------------------------------------------

class CrawledTask : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:spiderproto.CrawledTask) */ {
 public:
  CrawledTask();
  virtual ~CrawledTask();

  CrawledTask(const CrawledTask& from);

  inline CrawledTask& operator=(const CrawledTask& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CrawledTask(CrawledTask&& from) noexcept
    : CrawledTask() {
    *this = ::std::move(from);
  }

  inline CrawledTask& operator=(CrawledTask&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CrawledTask& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CrawledTask* internal_default_instance() {
    return reinterpret_cast<const CrawledTask*>(
               &_CrawledTask_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(CrawledTask* other);
  friend void swap(CrawledTask& a, CrawledTask& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CrawledTask* New() const final {
    return CreateMaybeMessage<CrawledTask>(NULL);
  }

  CrawledTask* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CrawledTask>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CrawledTask& from);
  void MergeFrom(const CrawledTask& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CrawledTask* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .spiderproto.CrawlUrl links = 5;
  int links_size() const;
  void clear_links();
  static const int kLinksFieldNumber = 5;
  ::spiderproto::CrawlUrl* mutable_links(int index);
  ::google::protobuf::RepeatedPtrField< ::spiderproto::CrawlUrl >*
      mutable_links();
  const ::spiderproto::CrawlUrl& links(int index) const;
  ::spiderproto::CrawlUrl* add_links();
  const ::google::protobuf::RepeatedPtrField< ::spiderproto::CrawlUrl >&
      links() const;

  // bytes taskid = 1;
  void clear_taskid();
  static const int kTaskidFieldNumber = 1;
  const ::std::string& taskid() const;
  void set_taskid(const ::std::string& value);
  #if LANG_CXX11
  void set_taskid(::std::string&& value);
  #endif
  void set_taskid(const char* value);
  void set_taskid(const void* value, size_t size);
  ::std::string* mutable_taskid();
  ::std::string* release_taskid();
  void set_allocated_taskid(::std::string* taskid);

  // bytes fetcher = 2;
  void clear_fetcher();
  static const int kFetcherFieldNumber = 2;
  const ::std::string& fetcher() const;
  void set_fetcher(const ::std::string& value);
  #if LANG_CXX11
  void set_fetcher(::std::string&& value);
  #endif
  void set_fetcher(const char* value);
  void set_fetcher(const void* value, size_t size);
  ::std::string* mutable_fetcher();
  ::std::string* release_fetcher();
  void set_allocated_fetcher(::std::string* fetcher);

  // .spiderproto.CrawlUrl crawl_url = 3;
  bool has_crawl_url() const;
  void clear_crawl_url();
  static const int kCrawlUrlFieldNumber = 3;
  const ::spiderproto::CrawlUrl& crawl_url() const;
  ::spiderproto::CrawlUrl* release_crawl_url();
  ::spiderproto::CrawlUrl* mutable_crawl_url();
  void set_allocated_crawl_url(::spiderproto::CrawlUrl* crawl_url);

  // int32 status = 4;
  void clear_status();
  static const int kStatusFieldNumber = 4;
  ::google::protobuf::int32 status() const;
  void set_status(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:spiderproto.CrawledTask)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::spiderproto::CrawlUrl > links_;
  ::google::protobuf::internal::ArenaStringPtr taskid_;
  ::google::protobuf::internal::ArenaStringPtr fetcher_;
  ::spiderproto::CrawlUrl* crawl_url_;
  ::google::protobuf::int32 status_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_spider_2eproto;
};
// -------------------------------------------------------------------

class CrawlStats : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:spiderproto.CrawlStats) */ {
 public:
  CrawlStats();
  virtual ~CrawlStats();

  CrawlStats(const CrawlStats& from);

  inline CrawlStats& operator=(const CrawlStats& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CrawlStats(CrawlStats&& from) noexcept
    : CrawlStats() {
    *this = ::std::move(from);
  }

  inline CrawlStats& operator=(CrawlStats&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CrawlStats& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CrawlStats* internal_default_instance() {
    return reinterpret_cast<const CrawlStats*>(
               &_CrawlStats_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(CrawlStats* other);
  friend void swap(CrawlStats& a, CrawlStats& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CrawlStats* New() const final {
    return CreateMaybeMessage<CrawlStats>(NULL);
  }

  CrawlStats* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CrawlStats>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CrawlStats& from);
  void MergeFrom(const CrawlStats& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CrawlStats* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes taskid = 1;
  void clear_taskid();
  static const int kTaskidFieldNumber = 1;
  const ::std::string& taskid() const;
  void set_taskid(const ::std::string& value);
  #if LANG_CXX11
  void set_taskid(::std::string&& value);
  #endif
  void set_taskid(const char* value);
  void set_taskid(const void* value, size_t size);
  ::std::string* mutable_taskid();
  ::std::string* release_taskid();
  void set_allocated_taskid(::std::string* taskid);

  // bytes start_time = 2;
  void clear_start_time();
  static const int kStartTimeFieldNumber = 2;
  const ::std::string& start_time() const;
  void set_start_time(const ::std::string& value);
  #if LANG_CXX11
  void set_start_time(::std::string&& value);
  #endif
  void set_start_time(const char* value);
  void set_start_time(const void* value, size_t size);
  ::std::string* mutable_start_time();
  ::std::string* release_start_time();
  void set_allocated_start_time(::std::string* start_time);

  // bytes last_update = 3;
  void clear_last_update();
  static const int kLastUpdateFieldNumber = 3;
  const ::std::string& last_update() const;
  void set_last_update(const ::std::string& value);
  #if LANG_CXX11
  void set_last_update(::std::string&& value);
  #endif
  void set_last_update(const char* value);
  void set_last_update(const void* value, size_t size);
  ::std::string* mutable_last_update();
  ::std::string* release_last_update();
  void set_allocated_last_update(::std::string* last_update);

  // int32 total_url = 4;
  void clear_total_url();
  static const int kTotalUrlFieldNumber = 4;
  ::google::protobuf::int32 total_url() const;
  void set_total_url(::google::protobuf::int32 value);

  // int32 success = 5;
  void clear_success();
  static const int kSuccessFieldNumber = 5;
  ::google::protobuf::int32 success() const;
  void set_success(::google::protobuf::int32 value);

  // int32 code40x = 6;
  void clear_code40x();
  static const int kCode40XFieldNumber = 6;
  ::google::protobuf::int32 code40x() const;
  void set_code40x(::google::protobuf::int32 value);

  // int32 code404 = 7;
  void clear_code404();
  static const int kCode404FieldNumber = 7;
  ::google::protobuf::int32 code404() const;
  void set_code404(::google::protobuf::int32 value);

  // int32 code50x = 8;
  void clear_code50x();
  static const int kCode50XFieldNumber = 8;
  ::google::protobuf::int32 code50x() const;
  void set_code50x(::google::protobuf::int32 value);

  // int32 codexxx = 9;
  void clear_codexxx();
  static const int kCodexxxFieldNumber = 9;
  ::google::protobuf::int32 codexxx() const;
  void set_codexxx(::google::protobuf::int32 value);

  // int32 links = 10;
  void clear_links();
  static const int kLinksFieldNumber = 10;
  ::google::protobuf::int32 links() const;
  void set_links(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:spiderproto.CrawlStats)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr taskid_;
  ::google::protobuf::internal::ArenaStringPtr start_time_;
  ::google::protobuf::internal::ArenaStringPtr last_update_;
  ::google::protobuf::int32 total_url_;
  ::google::protobuf::int32 success_;
  ::google::protobuf::int32 code40x_;
  ::google::protobuf::int32 code404_;
  ::google::protobuf::int32 code50x_;
  ::google::protobuf::int32 codexxx_;
  ::google::protobuf::int32 links_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_spider_2eproto;
};
// -------------------------------------------------------------------

class TaskResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:spiderproto.TaskResponse) */ {
 public:
  TaskResponse();
  virtual ~TaskResponse();

  TaskResponse(const TaskResponse& from);

  inline TaskResponse& operator=(const TaskResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TaskResponse(TaskResponse&& from) noexcept
    : TaskResponse() {
    *this = ::std::move(from);
  }

  inline TaskResponse& operator=(TaskResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const TaskResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TaskResponse* internal_default_instance() {
    return reinterpret_cast<const TaskResponse*>(
               &_TaskResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(TaskResponse* other);
  friend void swap(TaskResponse& a, TaskResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TaskResponse* New() const final {
    return CreateMaybeMessage<TaskResponse>(NULL);
  }

  TaskResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TaskResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TaskResponse& from);
  void MergeFrom(const TaskResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TaskResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes taskid = 1;
  void clear_taskid();
  static const int kTaskidFieldNumber = 1;
  const ::std::string& taskid() const;
  void set_taskid(const ::std::string& value);
  #if LANG_CXX11
  void set_taskid(::std::string&& value);
  #endif
  void set_taskid(const char* value);
  void set_taskid(const void* value, size_t size);
  ::std::string* mutable_taskid();
  ::std::string* release_taskid();
  void set_allocated_taskid(::std::string* taskid);

  // bytes msg = 3;
  void clear_msg();
  static const int kMsgFieldNumber = 3;
  const ::std::string& msg() const;
  void set_msg(const ::std::string& value);
  #if LANG_CXX11
  void set_msg(::std::string&& value);
  #endif
  void set_msg(const char* value);
  void set_msg(const void* value, size_t size);
  ::std::string* mutable_msg();
  ::std::string* release_msg();
  void set_allocated_msg(::std::string* msg);

  // int32 code = 2;
  void clear_code();
  static const int kCodeFieldNumber = 2;
  ::google::protobuf::int32 code() const;
  void set_code(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:spiderproto.TaskResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr taskid_;
  ::google::protobuf::internal::ArenaStringPtr msg_;
  ::google::protobuf::int32 code_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_spider_2eproto;
};
// -------------------------------------------------------------------

class Empty : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:spiderproto.Empty) */ {
 public:
  Empty();
  virtual ~Empty();

  Empty(const Empty& from);

  inline Empty& operator=(const Empty& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Empty(Empty&& from) noexcept
    : Empty() {
    *this = ::std::move(from);
  }

  inline Empty& operator=(Empty&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Empty& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Empty* internal_default_instance() {
    return reinterpret_cast<const Empty*>(
               &_Empty_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(Empty* other);
  friend void swap(Empty& a, Empty& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Empty* New() const final {
    return CreateMaybeMessage<Empty>(NULL);
  }

  Empty* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Empty>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Empty& from);
  void MergeFrom(const Empty& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Empty* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:spiderproto.Empty)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_spider_2eproto;
};
// -------------------------------------------------------------------

class Fetcher : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:spiderproto.Fetcher) */ {
 public:
  Fetcher();
  virtual ~Fetcher();

  Fetcher(const Fetcher& from);

  inline Fetcher& operator=(const Fetcher& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Fetcher(Fetcher&& from) noexcept
    : Fetcher() {
    *this = ::std::move(from);
  }

  inline Fetcher& operator=(Fetcher&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Fetcher& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Fetcher* internal_default_instance() {
    return reinterpret_cast<const Fetcher*>(
               &_Fetcher_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(Fetcher* other);
  friend void swap(Fetcher& a, Fetcher& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Fetcher* New() const final {
    return CreateMaybeMessage<Fetcher>(NULL);
  }

  Fetcher* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Fetcher>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Fetcher& from);
  void MergeFrom(const Fetcher& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Fetcher* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const void* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // bytes addr = 2;
  void clear_addr();
  static const int kAddrFieldNumber = 2;
  const ::std::string& addr() const;
  void set_addr(const ::std::string& value);
  #if LANG_CXX11
  void set_addr(::std::string&& value);
  #endif
  void set_addr(const char* value);
  void set_addr(const void* value, size_t size);
  ::std::string* mutable_addr();
  ::std::string* release_addr();
  void set_allocated_addr(::std::string* addr);

  // @@protoc_insertion_point(class_scope:spiderproto.Fetcher)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr addr_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_spider_2eproto;
};
// -------------------------------------------------------------------

class Segment : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:spiderproto.Segment) */ {
 public:
  Segment();
  virtual ~Segment();

  Segment(const Segment& from);

  inline Segment& operator=(const Segment& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Segment(Segment&& from) noexcept
    : Segment() {
    *this = ::std::move(from);
  }

  inline Segment& operator=(Segment&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Segment& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Segment* internal_default_instance() {
    return reinterpret_cast<const Segment*>(
               &_Segment_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(Segment* other);
  friend void swap(Segment& a, Segment& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Segment* New() const final {
    return CreateMaybeMessage<Segment>(NULL);
  }

  Segment* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Segment>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Segment& from);
  void MergeFrom(const Segment& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Segment* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes word = 1;
  void clear_word();
  static const int kWordFieldNumber = 1;
  const ::std::string& word() const;
  void set_word(const ::std::string& value);
  #if LANG_CXX11
  void set_word(::std::string&& value);
  #endif
  void set_word(const char* value);
  void set_word(const void* value, size_t size);
  ::std::string* mutable_word();
  ::std::string* release_word();
  void set_allocated_word(::std::string* word);

  // int32 score = 2;
  void clear_score();
  static const int kScoreFieldNumber = 2;
  ::google::protobuf::int32 score() const;
  void set_score(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:spiderproto.Segment)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr word_;
  ::google::protobuf::int32 score_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_spider_2eproto;
};
// -------------------------------------------------------------------

class SegmentList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:spiderproto.SegmentList) */ {
 public:
  SegmentList();
  virtual ~SegmentList();

  SegmentList(const SegmentList& from);

  inline SegmentList& operator=(const SegmentList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SegmentList(SegmentList&& from) noexcept
    : SegmentList() {
    *this = ::std::move(from);
  }

  inline SegmentList& operator=(SegmentList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const SegmentList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SegmentList* internal_default_instance() {
    return reinterpret_cast<const SegmentList*>(
               &_SegmentList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(SegmentList* other);
  friend void swap(SegmentList& a, SegmentList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SegmentList* New() const final {
    return CreateMaybeMessage<SegmentList>(NULL);
  }

  SegmentList* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SegmentList>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SegmentList& from);
  void MergeFrom(const SegmentList& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SegmentList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .spiderproto.Segment segments = 1;
  int segments_size() const;
  void clear_segments();
  static const int kSegmentsFieldNumber = 1;
  ::spiderproto::Segment* mutable_segments(int index);
  ::google::protobuf::RepeatedPtrField< ::spiderproto::Segment >*
      mutable_segments();
  const ::spiderproto::Segment& segments(int index) const;
  ::spiderproto::Segment* add_segments();
  const ::google::protobuf::RepeatedPtrField< ::spiderproto::Segment >&
      segments() const;

  // @@protoc_insertion_point(class_scope:spiderproto.SegmentList)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::spiderproto::Segment > segments_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_spider_2eproto;
};
// -------------------------------------------------------------------

class CrawlDoc : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:spiderproto.CrawlDoc) */ {
 public:
  CrawlDoc();
  virtual ~CrawlDoc();

  CrawlDoc(const CrawlDoc& from);

  inline CrawlDoc& operator=(const CrawlDoc& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CrawlDoc(CrawlDoc&& from) noexcept
    : CrawlDoc() {
    *this = ::std::move(from);
  }

  inline CrawlDoc& operator=(CrawlDoc&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CrawlDoc& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CrawlDoc* internal_default_instance() {
    return reinterpret_cast<const CrawlDoc*>(
               &_CrawlDoc_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(CrawlDoc* other);
  friend void swap(CrawlDoc& a, CrawlDoc& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CrawlDoc* New() const final {
    return CreateMaybeMessage<CrawlDoc>(NULL);
  }

  CrawlDoc* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CrawlDoc>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CrawlDoc& from);
  void MergeFrom(const CrawlDoc& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CrawlDoc* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes taskid = 1;
  void clear_taskid();
  static const int kTaskidFieldNumber = 1;
  const ::std::string& taskid() const;
  void set_taskid(const ::std::string& value);
  #if LANG_CXX11
  void set_taskid(::std::string&& value);
  #endif
  void set_taskid(const char* value);
  void set_taskid(const void* value, size_t size);
  ::std::string* mutable_taskid();
  ::std::string* release_taskid();
  void set_allocated_taskid(::std::string* taskid);

  // bytes url = 2;
  void clear_url();
  static const int kUrlFieldNumber = 2;
  const ::std::string& url() const;
  void set_url(const ::std::string& value);
  #if LANG_CXX11
  void set_url(::std::string&& value);
  #endif
  void set_url(const char* value);
  void set_url(const void* value, size_t size);
  ::std::string* mutable_url();
  ::std::string* release_url();
  void set_allocated_url(::std::string* url);

  // bytes content = 4;
  void clear_content();
  static const int kContentFieldNumber = 4;
  const ::std::string& content() const;
  void set_content(const ::std::string& value);
  #if LANG_CXX11
  void set_content(::std::string&& value);
  #endif
  void set_content(const char* value);
  void set_content(const void* value, size_t size);
  ::std::string* mutable_content();
  ::std::string* release_content();
  void set_allocated_content(::std::string* content);

  // .spiderproto.Storage storage = 5;
  bool has_storage() const;
  void clear_storage();
  static const int kStorageFieldNumber = 5;
  const ::spiderproto::Storage& storage() const;
  ::spiderproto::Storage* release_storage();
  ::spiderproto::Storage* mutable_storage();
  void set_allocated_storage(::spiderproto::Storage* storage);

  // .spiderproto.SegmentList segment_list = 6;
  bool has_segment_list() const;
  void clear_segment_list();
  static const int kSegmentListFieldNumber = 6;
  const ::spiderproto::SegmentList& segment_list() const;
  ::spiderproto::SegmentList* release_segment_list();
  ::spiderproto::SegmentList* mutable_segment_list();
  void set_allocated_segment_list(::spiderproto::SegmentList* segment_list);

  // int32 status = 3;
  void clear_status();
  static const int kStatusFieldNumber = 3;
  ::google::protobuf::int32 status() const;
  void set_status(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:spiderproto.CrawlDoc)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr taskid_;
  ::google::protobuf::internal::ArenaStringPtr url_;
  ::google::protobuf::internal::ArenaStringPtr content_;
  ::spiderproto::Storage* storage_;
  ::spiderproto::SegmentList* segment_list_;
  ::google::protobuf::int32 status_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_spider_2eproto;
};
// -------------------------------------------------------------------

class CrawlDocs : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:spiderproto.CrawlDocs) */ {
 public:
  CrawlDocs();
  virtual ~CrawlDocs();

  CrawlDocs(const CrawlDocs& from);

  inline CrawlDocs& operator=(const CrawlDocs& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CrawlDocs(CrawlDocs&& from) noexcept
    : CrawlDocs() {
    *this = ::std::move(from);
  }

  inline CrawlDocs& operator=(CrawlDocs&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CrawlDocs& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CrawlDocs* internal_default_instance() {
    return reinterpret_cast<const CrawlDocs*>(
               &_CrawlDocs_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(CrawlDocs* other);
  friend void swap(CrawlDocs& a, CrawlDocs& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CrawlDocs* New() const final {
    return CreateMaybeMessage<CrawlDocs>(NULL);
  }

  CrawlDocs* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CrawlDocs>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CrawlDocs& from);
  void MergeFrom(const CrawlDocs& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CrawlDocs* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .spiderproto.CrawlDoc docs = 2;
  int docs_size() const;
  void clear_docs();
  static const int kDocsFieldNumber = 2;
  ::spiderproto::CrawlDoc* mutable_docs(int index);
  ::google::protobuf::RepeatedPtrField< ::spiderproto::CrawlDoc >*
      mutable_docs();
  const ::spiderproto::CrawlDoc& docs(int index) const;
  ::spiderproto::CrawlDoc* add_docs();
  const ::google::protobuf::RepeatedPtrField< ::spiderproto::CrawlDoc >&
      docs() const;

  // bytes taskid = 1;
  void clear_taskid();
  static const int kTaskidFieldNumber = 1;
  const ::std::string& taskid() const;
  void set_taskid(const ::std::string& value);
  #if LANG_CXX11
  void set_taskid(::std::string&& value);
  #endif
  void set_taskid(const char* value);
  void set_taskid(const void* value, size_t size);
  ::std::string* mutable_taskid();
  ::std::string* release_taskid();
  void set_allocated_taskid(::std::string* taskid);

  // @@protoc_insertion_point(class_scope:spiderproto.CrawlDocs)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::spiderproto::CrawlDoc > docs_;
  ::google::protobuf::internal::ArenaStringPtr taskid_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_spider_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CrawlUrl

// bytes url = 1;
inline void CrawlUrl::clear_url() {
  url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CrawlUrl::url() const {
  // @@protoc_insertion_point(field_get:spiderproto.CrawlUrl.url)
  return url_.GetNoArena();
}
inline void CrawlUrl::set_url(const ::std::string& value) {
  
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:spiderproto.CrawlUrl.url)
}
#if LANG_CXX11
inline void CrawlUrl::set_url(::std::string&& value) {
  
  url_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:spiderproto.CrawlUrl.url)
}
#endif
inline void CrawlUrl::set_url(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:spiderproto.CrawlUrl.url)
}
inline void CrawlUrl::set_url(const void* value, size_t size) {
  
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:spiderproto.CrawlUrl.url)
}
inline ::std::string* CrawlUrl::mutable_url() {
  
  // @@protoc_insertion_point(field_mutable:spiderproto.CrawlUrl.url)
  return url_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CrawlUrl::release_url() {
  // @@protoc_insertion_point(field_release:spiderproto.CrawlUrl.url)
  
  return url_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CrawlUrl::set_allocated_url(::std::string* url) {
  if (url != NULL) {
    
  } else {
    
  }
  url_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), url);
  // @@protoc_insertion_point(field_set_allocated:spiderproto.CrawlUrl.url)
}

// .spiderproto.UrlLevel level = 2;
inline void CrawlUrl::clear_level() {
  level_ = 0;
}
inline ::spiderproto::UrlLevel CrawlUrl::level() const {
  // @@protoc_insertion_point(field_get:spiderproto.CrawlUrl.level)
  return static_cast< ::spiderproto::UrlLevel >(level_);
}
inline void CrawlUrl::set_level(::spiderproto::UrlLevel value) {
  
  level_ = value;
  // @@protoc_insertion_point(field_set:spiderproto.CrawlUrl.level)
}

// bool usedable = 3;
inline void CrawlUrl::clear_usedable() {
  usedable_ = false;
}
inline bool CrawlUrl::usedable() const {
  // @@protoc_insertion_point(field_get:spiderproto.CrawlUrl.usedable)
  return usedable_;
}
inline void CrawlUrl::set_usedable(bool value) {
  
  usedable_ = value;
  // @@protoc_insertion_point(field_set:spiderproto.CrawlUrl.usedable)
}

// -------------------------------------------------------------------

// Feature

// bool dup_ignore = 1;
inline void Feature::clear_dup_ignore() {
  dup_ignore_ = false;
}
inline bool Feature::dup_ignore() const {
  // @@protoc_insertion_point(field_get:spiderproto.Feature.dup_ignore)
  return dup_ignore_;
}
inline void Feature::set_dup_ignore(bool value) {
  
  dup_ignore_ = value;
  // @@protoc_insertion_point(field_set:spiderproto.Feature.dup_ignore)
}

// bool testing = 2;
inline void Feature::clear_testing() {
  testing_ = false;
}
inline bool Feature::testing() const {
  // @@protoc_insertion_point(field_get:spiderproto.Feature.testing)
  return testing_;
}
inline void Feature::set_testing(bool value) {
  
  testing_ = value;
  // @@protoc_insertion_point(field_set:spiderproto.Feature.testing)
}

// bool period = 3;
inline void Feature::clear_period() {
  period_ = false;
}
inline bool Feature::period() const {
  // @@protoc_insertion_point(field_get:spiderproto.Feature.period)
  return period_;
}
inline void Feature::set_period(bool value) {
  
  period_ = value;
  // @@protoc_insertion_point(field_set:spiderproto.Feature.period)
}

// int32 interval = 4;
inline void Feature::clear_interval() {
  interval_ = 0;
}
inline ::google::protobuf::int32 Feature::interval() const {
  // @@protoc_insertion_point(field_get:spiderproto.Feature.interval)
  return interval_;
}
inline void Feature::set_interval(::google::protobuf::int32 value) {
  
  interval_ = value;
  // @@protoc_insertion_point(field_set:spiderproto.Feature.interval)
}

// -------------------------------------------------------------------

// LinkRule

// .spiderproto.UrlLevel in_level = 1;
inline void LinkRule::clear_in_level() {
  in_level_ = 0;
}
inline ::spiderproto::UrlLevel LinkRule::in_level() const {
  // @@protoc_insertion_point(field_get:spiderproto.LinkRule.in_level)
  return static_cast< ::spiderproto::UrlLevel >(in_level_);
}
inline void LinkRule::set_in_level(::spiderproto::UrlLevel value) {
  
  in_level_ = value;
  // @@protoc_insertion_point(field_set:spiderproto.LinkRule.in_level)
}

// repeated bytes rules = 2;
inline int LinkRule::rules_size() const {
  return rules_.size();
}
inline void LinkRule::clear_rules() {
  rules_.Clear();
}
inline const ::std::string& LinkRule::rules(int index) const {
  // @@protoc_insertion_point(field_get:spiderproto.LinkRule.rules)
  return rules_.Get(index);
}
inline ::std::string* LinkRule::mutable_rules(int index) {
  // @@protoc_insertion_point(field_mutable:spiderproto.LinkRule.rules)
  return rules_.Mutable(index);
}
inline void LinkRule::set_rules(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:spiderproto.LinkRule.rules)
  rules_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void LinkRule::set_rules(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:spiderproto.LinkRule.rules)
  rules_.Mutable(index)->assign(std::move(value));
}
#endif
inline void LinkRule::set_rules(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  rules_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:spiderproto.LinkRule.rules)
}
inline void LinkRule::set_rules(int index, const void* value, size_t size) {
  rules_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:spiderproto.LinkRule.rules)
}
inline ::std::string* LinkRule::add_rules() {
  // @@protoc_insertion_point(field_add_mutable:spiderproto.LinkRule.rules)
  return rules_.Add();
}
inline void LinkRule::add_rules(const ::std::string& value) {
  rules_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:spiderproto.LinkRule.rules)
}
#if LANG_CXX11
inline void LinkRule::add_rules(::std::string&& value) {
  rules_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:spiderproto.LinkRule.rules)
}
#endif
inline void LinkRule::add_rules(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  rules_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:spiderproto.LinkRule.rules)
}
inline void LinkRule::add_rules(const void* value, size_t size) {
  rules_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:spiderproto.LinkRule.rules)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
LinkRule::rules() const {
  // @@protoc_insertion_point(field_list:spiderproto.LinkRule.rules)
  return rules_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>*
LinkRule::mutable_rules() {
  // @@protoc_insertion_point(field_mutable_list:spiderproto.LinkRule.rules)
  return &rules_;
}

// .spiderproto.UrlLevel out_level = 3;
inline void LinkRule::clear_out_level() {
  out_level_ = 0;
}
inline ::spiderproto::UrlLevel LinkRule::out_level() const {
  // @@protoc_insertion_point(field_get:spiderproto.LinkRule.out_level)
  return static_cast< ::spiderproto::UrlLevel >(out_level_);
}
inline void LinkRule::set_out_level(::spiderproto::UrlLevel value) {
  
  out_level_ = value;
  // @@protoc_insertion_point(field_set:spiderproto.LinkRule.out_level)
}

// -------------------------------------------------------------------

// Storage

// .spiderproto.Storage.StorageType store_type = 1;
inline void Storage::clear_store_type() {
  store_type_ = 0;
}
inline ::spiderproto::Storage_StorageType Storage::store_type() const {
  // @@protoc_insertion_point(field_get:spiderproto.Storage.store_type)
  return static_cast< ::spiderproto::Storage_StorageType >(store_type_);
}
inline void Storage::set_store_type(::spiderproto::Storage_StorageType value) {
  
  store_type_ = value;
  // @@protoc_insertion_point(field_set:spiderproto.Storage.store_type)
}

// bytes dest = 2;
inline void Storage::clear_dest() {
  dest_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Storage::dest() const {
  // @@protoc_insertion_point(field_get:spiderproto.Storage.dest)
  return dest_.GetNoArena();
}
inline void Storage::set_dest(const ::std::string& value) {
  
  dest_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:spiderproto.Storage.dest)
}
#if LANG_CXX11
inline void Storage::set_dest(::std::string&& value) {
  
  dest_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:spiderproto.Storage.dest)
}
#endif
inline void Storage::set_dest(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  dest_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:spiderproto.Storage.dest)
}
inline void Storage::set_dest(const void* value, size_t size) {
  
  dest_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:spiderproto.Storage.dest)
}
inline ::std::string* Storage::mutable_dest() {
  
  // @@protoc_insertion_point(field_mutable:spiderproto.Storage.dest)
  return dest_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Storage::release_dest() {
  // @@protoc_insertion_point(field_release:spiderproto.Storage.dest)
  
  return dest_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Storage::set_allocated_dest(::std::string* dest) {
  if (dest != NULL) {
    
  } else {
    
  }
  dest_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), dest);
  // @@protoc_insertion_point(field_set_allocated:spiderproto.Storage.dest)
}

// bytes attachment = 3;
inline void Storage::clear_attachment() {
  attachment_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Storage::attachment() const {
  // @@protoc_insertion_point(field_get:spiderproto.Storage.attachment)
  return attachment_.GetNoArena();
}
inline void Storage::set_attachment(const ::std::string& value) {
  
  attachment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:spiderproto.Storage.attachment)
}
#if LANG_CXX11
inline void Storage::set_attachment(::std::string&& value) {
  
  attachment_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:spiderproto.Storage.attachment)
}
#endif
inline void Storage::set_attachment(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  attachment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:spiderproto.Storage.attachment)
}
inline void Storage::set_attachment(const void* value, size_t size) {
  
  attachment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:spiderproto.Storage.attachment)
}
inline ::std::string* Storage::mutable_attachment() {
  
  // @@protoc_insertion_point(field_mutable:spiderproto.Storage.attachment)
  return attachment_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Storage::release_attachment() {
  // @@protoc_insertion_point(field_release:spiderproto.Storage.attachment)
  
  return attachment_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Storage::set_allocated_attachment(::std::string* attachment) {
  if (attachment != NULL) {
    
  } else {
    
  }
  attachment_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), attachment);
  // @@protoc_insertion_point(field_set_allocated:spiderproto.Storage.attachment)
}

// -------------------------------------------------------------------

// Runtime

// float download_delay = 1;
inline void Runtime::clear_download_delay() {
  download_delay_ = 0;
}
inline float Runtime::download_delay() const {
  // @@protoc_insertion_point(field_get:spiderproto.Runtime.download_delay)
  return download_delay_;
}
inline void Runtime::set_download_delay(float value) {
  
  download_delay_ = value;
  // @@protoc_insertion_point(field_set:spiderproto.Runtime.download_delay)
}

// int32 concurrent_reqs = 2;
inline void Runtime::clear_concurrent_reqs() {
  concurrent_reqs_ = 0;
}
inline ::google::protobuf::int32 Runtime::concurrent_reqs() const {
  // @@protoc_insertion_point(field_get:spiderproto.Runtime.concurrent_reqs)
  return concurrent_reqs_;
}
inline void Runtime::set_concurrent_reqs(::google::protobuf::int32 value) {
  
  concurrent_reqs_ = value;
  // @@protoc_insertion_point(field_set:spiderproto.Runtime.concurrent_reqs)
}

// repeated bytes allow_fetchers = 3;
inline int Runtime::allow_fetchers_size() const {
  return allow_fetchers_.size();
}
inline void Runtime::clear_allow_fetchers() {
  allow_fetchers_.Clear();
}
inline const ::std::string& Runtime::allow_fetchers(int index) const {
  // @@protoc_insertion_point(field_get:spiderproto.Runtime.allow_fetchers)
  return allow_fetchers_.Get(index);
}
inline ::std::string* Runtime::mutable_allow_fetchers(int index) {
  // @@protoc_insertion_point(field_mutable:spiderproto.Runtime.allow_fetchers)
  return allow_fetchers_.Mutable(index);
}
inline void Runtime::set_allow_fetchers(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:spiderproto.Runtime.allow_fetchers)
  allow_fetchers_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Runtime::set_allow_fetchers(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:spiderproto.Runtime.allow_fetchers)
  allow_fetchers_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Runtime::set_allow_fetchers(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  allow_fetchers_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:spiderproto.Runtime.allow_fetchers)
}
inline void Runtime::set_allow_fetchers(int index, const void* value, size_t size) {
  allow_fetchers_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:spiderproto.Runtime.allow_fetchers)
}
inline ::std::string* Runtime::add_allow_fetchers() {
  // @@protoc_insertion_point(field_add_mutable:spiderproto.Runtime.allow_fetchers)
  return allow_fetchers_.Add();
}
inline void Runtime::add_allow_fetchers(const ::std::string& value) {
  allow_fetchers_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:spiderproto.Runtime.allow_fetchers)
}
#if LANG_CXX11
inline void Runtime::add_allow_fetchers(::std::string&& value) {
  allow_fetchers_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:spiderproto.Runtime.allow_fetchers)
}
#endif
inline void Runtime::add_allow_fetchers(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  allow_fetchers_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:spiderproto.Runtime.allow_fetchers)
}
inline void Runtime::add_allow_fetchers(const void* value, size_t size) {
  allow_fetchers_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:spiderproto.Runtime.allow_fetchers)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
Runtime::allow_fetchers() const {
  // @@protoc_insertion_point(field_list:spiderproto.Runtime.allow_fetchers)
  return allow_fetchers_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>*
Runtime::mutable_allow_fetchers() {
  // @@protoc_insertion_point(field_mutable_list:spiderproto.Runtime.allow_fetchers)
  return &allow_fetchers_;
}

// repeated bytes deny_fetchers = 4;
inline int Runtime::deny_fetchers_size() const {
  return deny_fetchers_.size();
}
inline void Runtime::clear_deny_fetchers() {
  deny_fetchers_.Clear();
}
inline const ::std::string& Runtime::deny_fetchers(int index) const {
  // @@protoc_insertion_point(field_get:spiderproto.Runtime.deny_fetchers)
  return deny_fetchers_.Get(index);
}
inline ::std::string* Runtime::mutable_deny_fetchers(int index) {
  // @@protoc_insertion_point(field_mutable:spiderproto.Runtime.deny_fetchers)
  return deny_fetchers_.Mutable(index);
}
inline void Runtime::set_deny_fetchers(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:spiderproto.Runtime.deny_fetchers)
  deny_fetchers_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Runtime::set_deny_fetchers(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:spiderproto.Runtime.deny_fetchers)
  deny_fetchers_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Runtime::set_deny_fetchers(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  deny_fetchers_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:spiderproto.Runtime.deny_fetchers)
}
inline void Runtime::set_deny_fetchers(int index, const void* value, size_t size) {
  deny_fetchers_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:spiderproto.Runtime.deny_fetchers)
}
inline ::std::string* Runtime::add_deny_fetchers() {
  // @@protoc_insertion_point(field_add_mutable:spiderproto.Runtime.deny_fetchers)
  return deny_fetchers_.Add();
}
inline void Runtime::add_deny_fetchers(const ::std::string& value) {
  deny_fetchers_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:spiderproto.Runtime.deny_fetchers)
}
#if LANG_CXX11
inline void Runtime::add_deny_fetchers(::std::string&& value) {
  deny_fetchers_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:spiderproto.Runtime.deny_fetchers)
}
#endif
inline void Runtime::add_deny_fetchers(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  deny_fetchers_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:spiderproto.Runtime.deny_fetchers)
}
inline void Runtime::add_deny_fetchers(const void* value, size_t size) {
  deny_fetchers_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:spiderproto.Runtime.deny_fetchers)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
Runtime::deny_fetchers() const {
  // @@protoc_insertion_point(field_list:spiderproto.Runtime.deny_fetchers)
  return deny_fetchers_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>*
Runtime::mutable_deny_fetchers() {
  // @@protoc_insertion_point(field_mutable_list:spiderproto.Runtime.deny_fetchers)
  return &deny_fetchers_;
}

// -------------------------------------------------------------------

// BasicTask

// bytes taskid = 1;
inline void BasicTask::clear_taskid() {
  taskid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BasicTask::taskid() const {
  // @@protoc_insertion_point(field_get:spiderproto.BasicTask.taskid)
  return taskid_.GetNoArena();
}
inline void BasicTask::set_taskid(const ::std::string& value) {
  
  taskid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:spiderproto.BasicTask.taskid)
}
#if LANG_CXX11
inline void BasicTask::set_taskid(::std::string&& value) {
  
  taskid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:spiderproto.BasicTask.taskid)
}
#endif
inline void BasicTask::set_taskid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  taskid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:spiderproto.BasicTask.taskid)
}
inline void BasicTask::set_taskid(const void* value, size_t size) {
  
  taskid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:spiderproto.BasicTask.taskid)
}
inline ::std::string* BasicTask::mutable_taskid() {
  
  // @@protoc_insertion_point(field_mutable:spiderproto.BasicTask.taskid)
  return taskid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BasicTask::release_taskid() {
  // @@protoc_insertion_point(field_release:spiderproto.BasicTask.taskid)
  
  return taskid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BasicTask::set_allocated_taskid(::std::string* taskid) {
  if (taskid != NULL) {
    
  } else {
    
  }
  taskid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), taskid);
  // @@protoc_insertion_point(field_set_allocated:spiderproto.BasicTask.taskid)
}

// bytes name = 2;
inline void BasicTask::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BasicTask::name() const {
  // @@protoc_insertion_point(field_get:spiderproto.BasicTask.name)
  return name_.GetNoArena();
}
inline void BasicTask::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:spiderproto.BasicTask.name)
}
#if LANG_CXX11
inline void BasicTask::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:spiderproto.BasicTask.name)
}
#endif
inline void BasicTask::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:spiderproto.BasicTask.name)
}
inline void BasicTask::set_name(const void* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:spiderproto.BasicTask.name)
}
inline ::std::string* BasicTask::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:spiderproto.BasicTask.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BasicTask::release_name() {
  // @@protoc_insertion_point(field_release:spiderproto.BasicTask.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BasicTask::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:spiderproto.BasicTask.name)
}

// bytes user = 3;
inline void BasicTask::clear_user() {
  user_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BasicTask::user() const {
  // @@protoc_insertion_point(field_get:spiderproto.BasicTask.user)
  return user_.GetNoArena();
}
inline void BasicTask::set_user(const ::std::string& value) {
  
  user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:spiderproto.BasicTask.user)
}
#if LANG_CXX11
inline void BasicTask::set_user(::std::string&& value) {
  
  user_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:spiderproto.BasicTask.user)
}
#endif
inline void BasicTask::set_user(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:spiderproto.BasicTask.user)
}
inline void BasicTask::set_user(const void* value, size_t size) {
  
  user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:spiderproto.BasicTask.user)
}
inline ::std::string* BasicTask::mutable_user() {
  
  // @@protoc_insertion_point(field_mutable:spiderproto.BasicTask.user)
  return user_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BasicTask::release_user() {
  // @@protoc_insertion_point(field_release:spiderproto.BasicTask.user)
  
  return user_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BasicTask::set_allocated_user(::std::string* user) {
  if (user != NULL) {
    
  } else {
    
  }
  user_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), user);
  // @@protoc_insertion_point(field_set_allocated:spiderproto.BasicTask.user)
}

// .spiderproto.CrawlUrlList crawl_list = 4;
inline bool BasicTask::has_crawl_list() const {
  return this != internal_default_instance() && crawl_list_ != NULL;
}
inline void BasicTask::clear_crawl_list() {
  if (GetArenaNoVirtual() == NULL && crawl_list_ != NULL) {
    delete crawl_list_;
  }
  crawl_list_ = NULL;
}
inline const ::spiderproto::CrawlUrlList& BasicTask::crawl_list() const {
  const ::spiderproto::CrawlUrlList* p = crawl_list_;
  // @@protoc_insertion_point(field_get:spiderproto.BasicTask.crawl_list)
  return p != NULL ? *p : *reinterpret_cast<const ::spiderproto::CrawlUrlList*>(
      &::spiderproto::_CrawlUrlList_default_instance_);
}
inline ::spiderproto::CrawlUrlList* BasicTask::release_crawl_list() {
  // @@protoc_insertion_point(field_release:spiderproto.BasicTask.crawl_list)
  
  ::spiderproto::CrawlUrlList* temp = crawl_list_;
  crawl_list_ = NULL;
  return temp;
}
inline ::spiderproto::CrawlUrlList* BasicTask::mutable_crawl_list() {
  
  if (crawl_list_ == NULL) {
    auto* p = CreateMaybeMessage<::spiderproto::CrawlUrlList>(GetArenaNoVirtual());
    crawl_list_ = p;
  }
  // @@protoc_insertion_point(field_mutable:spiderproto.BasicTask.crawl_list)
  return crawl_list_;
}
inline void BasicTask::set_allocated_crawl_list(::spiderproto::CrawlUrlList* crawl_list) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete crawl_list_;
  }
  if (crawl_list) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      crawl_list = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, crawl_list, submessage_arena);
    }
    
  } else {
    
  }
  crawl_list_ = crawl_list;
  // @@protoc_insertion_point(field_set_allocated:spiderproto.BasicTask.crawl_list)
}

// .spiderproto.Feature feature = 5;
inline bool BasicTask::has_feature() const {
  return this != internal_default_instance() && feature_ != NULL;
}
inline void BasicTask::clear_feature() {
  if (GetArenaNoVirtual() == NULL && feature_ != NULL) {
    delete feature_;
  }
  feature_ = NULL;
}
inline const ::spiderproto::Feature& BasicTask::feature() const {
  const ::spiderproto::Feature* p = feature_;
  // @@protoc_insertion_point(field_get:spiderproto.BasicTask.feature)
  return p != NULL ? *p : *reinterpret_cast<const ::spiderproto::Feature*>(
      &::spiderproto::_Feature_default_instance_);
}
inline ::spiderproto::Feature* BasicTask::release_feature() {
  // @@protoc_insertion_point(field_release:spiderproto.BasicTask.feature)
  
  ::spiderproto::Feature* temp = feature_;
  feature_ = NULL;
  return temp;
}
inline ::spiderproto::Feature* BasicTask::mutable_feature() {
  
  if (feature_ == NULL) {
    auto* p = CreateMaybeMessage<::spiderproto::Feature>(GetArenaNoVirtual());
    feature_ = p;
  }
  // @@protoc_insertion_point(field_mutable:spiderproto.BasicTask.feature)
  return feature_;
}
inline void BasicTask::set_allocated_feature(::spiderproto::Feature* feature) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete feature_;
  }
  if (feature) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      feature = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, feature, submessage_arena);
    }
    
  } else {
    
  }
  feature_ = feature;
  // @@protoc_insertion_point(field_set_allocated:spiderproto.BasicTask.feature)
}

// .spiderproto.LinkRuleList rule_list = 6;
inline bool BasicTask::has_rule_list() const {
  return this != internal_default_instance() && rule_list_ != NULL;
}
inline void BasicTask::clear_rule_list() {
  if (GetArenaNoVirtual() == NULL && rule_list_ != NULL) {
    delete rule_list_;
  }
  rule_list_ = NULL;
}
inline const ::spiderproto::LinkRuleList& BasicTask::rule_list() const {
  const ::spiderproto::LinkRuleList* p = rule_list_;
  // @@protoc_insertion_point(field_get:spiderproto.BasicTask.rule_list)
  return p != NULL ? *p : *reinterpret_cast<const ::spiderproto::LinkRuleList*>(
      &::spiderproto::_LinkRuleList_default_instance_);
}
inline ::spiderproto::LinkRuleList* BasicTask::release_rule_list() {
  // @@protoc_insertion_point(field_release:spiderproto.BasicTask.rule_list)
  
  ::spiderproto::LinkRuleList* temp = rule_list_;
  rule_list_ = NULL;
  return temp;
}
inline ::spiderproto::LinkRuleList* BasicTask::mutable_rule_list() {
  
  if (rule_list_ == NULL) {
    auto* p = CreateMaybeMessage<::spiderproto::LinkRuleList>(GetArenaNoVirtual());
    rule_list_ = p;
  }
  // @@protoc_insertion_point(field_mutable:spiderproto.BasicTask.rule_list)
  return rule_list_;
}
inline void BasicTask::set_allocated_rule_list(::spiderproto::LinkRuleList* rule_list) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete rule_list_;
  }
  if (rule_list) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      rule_list = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, rule_list, submessage_arena);
    }
    
  } else {
    
  }
  rule_list_ = rule_list;
  // @@protoc_insertion_point(field_set_allocated:spiderproto.BasicTask.rule_list)
}

// .spiderproto.Storage storage = 7;
inline bool BasicTask::has_storage() const {
  return this != internal_default_instance() && storage_ != NULL;
}
inline void BasicTask::clear_storage() {
  if (GetArenaNoVirtual() == NULL && storage_ != NULL) {
    delete storage_;
  }
  storage_ = NULL;
}
inline const ::spiderproto::Storage& BasicTask::storage() const {
  const ::spiderproto::Storage* p = storage_;
  // @@protoc_insertion_point(field_get:spiderproto.BasicTask.storage)
  return p != NULL ? *p : *reinterpret_cast<const ::spiderproto::Storage*>(
      &::spiderproto::_Storage_default_instance_);
}
inline ::spiderproto::Storage* BasicTask::release_storage() {
  // @@protoc_insertion_point(field_release:spiderproto.BasicTask.storage)
  
  ::spiderproto::Storage* temp = storage_;
  storage_ = NULL;
  return temp;
}
inline ::spiderproto::Storage* BasicTask::mutable_storage() {
  
  if (storage_ == NULL) {
    auto* p = CreateMaybeMessage<::spiderproto::Storage>(GetArenaNoVirtual());
    storage_ = p;
  }
  // @@protoc_insertion_point(field_mutable:spiderproto.BasicTask.storage)
  return storage_;
}
inline void BasicTask::set_allocated_storage(::spiderproto::Storage* storage) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete storage_;
  }
  if (storage) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      storage = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, storage, submessage_arena);
    }
    
  } else {
    
  }
  storage_ = storage;
  // @@protoc_insertion_point(field_set_allocated:spiderproto.BasicTask.storage)
}

// .spiderproto.Runtime runtime = 8;
inline bool BasicTask::has_runtime() const {
  return this != internal_default_instance() && runtime_ != NULL;
}
inline void BasicTask::clear_runtime() {
  if (GetArenaNoVirtual() == NULL && runtime_ != NULL) {
    delete runtime_;
  }
  runtime_ = NULL;
}
inline const ::spiderproto::Runtime& BasicTask::runtime() const {
  const ::spiderproto::Runtime* p = runtime_;
  // @@protoc_insertion_point(field_get:spiderproto.BasicTask.runtime)
  return p != NULL ? *p : *reinterpret_cast<const ::spiderproto::Runtime*>(
      &::spiderproto::_Runtime_default_instance_);
}
inline ::spiderproto::Runtime* BasicTask::release_runtime() {
  // @@protoc_insertion_point(field_release:spiderproto.BasicTask.runtime)
  
  ::spiderproto::Runtime* temp = runtime_;
  runtime_ = NULL;
  return temp;
}
inline ::spiderproto::Runtime* BasicTask::mutable_runtime() {
  
  if (runtime_ == NULL) {
    auto* p = CreateMaybeMessage<::spiderproto::Runtime>(GetArenaNoVirtual());
    runtime_ = p;
  }
  // @@protoc_insertion_point(field_mutable:spiderproto.BasicTask.runtime)
  return runtime_;
}
inline void BasicTask::set_allocated_runtime(::spiderproto::Runtime* runtime) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete runtime_;
  }
  if (runtime) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      runtime = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, runtime, submessage_arena);
    }
    
  } else {
    
  }
  runtime_ = runtime;
  // @@protoc_insertion_point(field_set_allocated:spiderproto.BasicTask.runtime)
}

// -------------------------------------------------------------------

// CrawlUrlList

// repeated .spiderproto.CrawlUrl crawl_urls = 1;
inline int CrawlUrlList::crawl_urls_size() const {
  return crawl_urls_.size();
}
inline void CrawlUrlList::clear_crawl_urls() {
  crawl_urls_.Clear();
}
inline ::spiderproto::CrawlUrl* CrawlUrlList::mutable_crawl_urls(int index) {
  // @@protoc_insertion_point(field_mutable:spiderproto.CrawlUrlList.crawl_urls)
  return crawl_urls_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::spiderproto::CrawlUrl >*
CrawlUrlList::mutable_crawl_urls() {
  // @@protoc_insertion_point(field_mutable_list:spiderproto.CrawlUrlList.crawl_urls)
  return &crawl_urls_;
}
inline const ::spiderproto::CrawlUrl& CrawlUrlList::crawl_urls(int index) const {
  // @@protoc_insertion_point(field_get:spiderproto.CrawlUrlList.crawl_urls)
  return crawl_urls_.Get(index);
}
inline ::spiderproto::CrawlUrl* CrawlUrlList::add_crawl_urls() {
  // @@protoc_insertion_point(field_add:spiderproto.CrawlUrlList.crawl_urls)
  return crawl_urls_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::spiderproto::CrawlUrl >&
CrawlUrlList::crawl_urls() const {
  // @@protoc_insertion_point(field_list:spiderproto.CrawlUrlList.crawl_urls)
  return crawl_urls_;
}

// -------------------------------------------------------------------

// LinkRuleList

// repeated .spiderproto.LinkRule rules = 1;
inline int LinkRuleList::rules_size() const {
  return rules_.size();
}
inline void LinkRuleList::clear_rules() {
  rules_.Clear();
}
inline ::spiderproto::LinkRule* LinkRuleList::mutable_rules(int index) {
  // @@protoc_insertion_point(field_mutable:spiderproto.LinkRuleList.rules)
  return rules_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::spiderproto::LinkRule >*
LinkRuleList::mutable_rules() {
  // @@protoc_insertion_point(field_mutable_list:spiderproto.LinkRuleList.rules)
  return &rules_;
}
inline const ::spiderproto::LinkRule& LinkRuleList::rules(int index) const {
  // @@protoc_insertion_point(field_get:spiderproto.LinkRuleList.rules)
  return rules_.Get(index);
}
inline ::spiderproto::LinkRule* LinkRuleList::add_rules() {
  // @@protoc_insertion_point(field_add:spiderproto.LinkRuleList.rules)
  return rules_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::spiderproto::LinkRule >&
LinkRuleList::rules() const {
  // @@protoc_insertion_point(field_list:spiderproto.LinkRuleList.rules)
  return rules_;
}

// -------------------------------------------------------------------

// CrawlingTask

// bytes taskid = 1;
inline void CrawlingTask::clear_taskid() {
  taskid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CrawlingTask::taskid() const {
  // @@protoc_insertion_point(field_get:spiderproto.CrawlingTask.taskid)
  return taskid_.GetNoArena();
}
inline void CrawlingTask::set_taskid(const ::std::string& value) {
  
  taskid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:spiderproto.CrawlingTask.taskid)
}
#if LANG_CXX11
inline void CrawlingTask::set_taskid(::std::string&& value) {
  
  taskid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:spiderproto.CrawlingTask.taskid)
}
#endif
inline void CrawlingTask::set_taskid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  taskid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:spiderproto.CrawlingTask.taskid)
}
inline void CrawlingTask::set_taskid(const void* value, size_t size) {
  
  taskid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:spiderproto.CrawlingTask.taskid)
}
inline ::std::string* CrawlingTask::mutable_taskid() {
  
  // @@protoc_insertion_point(field_mutable:spiderproto.CrawlingTask.taskid)
  return taskid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CrawlingTask::release_taskid() {
  // @@protoc_insertion_point(field_release:spiderproto.CrawlingTask.taskid)
  
  return taskid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CrawlingTask::set_allocated_taskid(::std::string* taskid) {
  if (taskid != NULL) {
    
  } else {
    
  }
  taskid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), taskid);
  // @@protoc_insertion_point(field_set_allocated:spiderproto.CrawlingTask.taskid)
}

// bytes fetcher = 2;
inline void CrawlingTask::clear_fetcher() {
  fetcher_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CrawlingTask::fetcher() const {
  // @@protoc_insertion_point(field_get:spiderproto.CrawlingTask.fetcher)
  return fetcher_.GetNoArena();
}
inline void CrawlingTask::set_fetcher(const ::std::string& value) {
  
  fetcher_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:spiderproto.CrawlingTask.fetcher)
}
#if LANG_CXX11
inline void CrawlingTask::set_fetcher(::std::string&& value) {
  
  fetcher_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:spiderproto.CrawlingTask.fetcher)
}
#endif
inline void CrawlingTask::set_fetcher(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  fetcher_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:spiderproto.CrawlingTask.fetcher)
}
inline void CrawlingTask::set_fetcher(const void* value, size_t size) {
  
  fetcher_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:spiderproto.CrawlingTask.fetcher)
}
inline ::std::string* CrawlingTask::mutable_fetcher() {
  
  // @@protoc_insertion_point(field_mutable:spiderproto.CrawlingTask.fetcher)
  return fetcher_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CrawlingTask::release_fetcher() {
  // @@protoc_insertion_point(field_release:spiderproto.CrawlingTask.fetcher)
  
  return fetcher_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CrawlingTask::set_allocated_fetcher(::std::string* fetcher) {
  if (fetcher != NULL) {
    
  } else {
    
  }
  fetcher_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), fetcher);
  // @@protoc_insertion_point(field_set_allocated:spiderproto.CrawlingTask.fetcher)
}

// repeated .spiderproto.CrawlUrl crawl_urls = 3;
inline int CrawlingTask::crawl_urls_size() const {
  return crawl_urls_.size();
}
inline void CrawlingTask::clear_crawl_urls() {
  crawl_urls_.Clear();
}
inline ::spiderproto::CrawlUrl* CrawlingTask::mutable_crawl_urls(int index) {
  // @@protoc_insertion_point(field_mutable:spiderproto.CrawlingTask.crawl_urls)
  return crawl_urls_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::spiderproto::CrawlUrl >*
CrawlingTask::mutable_crawl_urls() {
  // @@protoc_insertion_point(field_mutable_list:spiderproto.CrawlingTask.crawl_urls)
  return &crawl_urls_;
}
inline const ::spiderproto::CrawlUrl& CrawlingTask::crawl_urls(int index) const {
  // @@protoc_insertion_point(field_get:spiderproto.CrawlingTask.crawl_urls)
  return crawl_urls_.Get(index);
}
inline ::spiderproto::CrawlUrl* CrawlingTask::add_crawl_urls() {
  // @@protoc_insertion_point(field_add:spiderproto.CrawlingTask.crawl_urls)
  return crawl_urls_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::spiderproto::CrawlUrl >&
CrawlingTask::crawl_urls() const {
  // @@protoc_insertion_point(field_list:spiderproto.CrawlingTask.crawl_urls)
  return crawl_urls_;
}

// repeated .spiderproto.LinkRule rules = 4;
inline int CrawlingTask::rules_size() const {
  return rules_.size();
}
inline void CrawlingTask::clear_rules() {
  rules_.Clear();
}
inline ::spiderproto::LinkRule* CrawlingTask::mutable_rules(int index) {
  // @@protoc_insertion_point(field_mutable:spiderproto.CrawlingTask.rules)
  return rules_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::spiderproto::LinkRule >*
CrawlingTask::mutable_rules() {
  // @@protoc_insertion_point(field_mutable_list:spiderproto.CrawlingTask.rules)
  return &rules_;
}
inline const ::spiderproto::LinkRule& CrawlingTask::rules(int index) const {
  // @@protoc_insertion_point(field_get:spiderproto.CrawlingTask.rules)
  return rules_.Get(index);
}
inline ::spiderproto::LinkRule* CrawlingTask::add_rules() {
  // @@protoc_insertion_point(field_add:spiderproto.CrawlingTask.rules)
  return rules_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::spiderproto::LinkRule >&
CrawlingTask::rules() const {
  // @@protoc_insertion_point(field_list:spiderproto.CrawlingTask.rules)
  return rules_;
}

// .spiderproto.Storage storage = 5;
inline bool CrawlingTask::has_storage() const {
  return this != internal_default_instance() && storage_ != NULL;
}
inline void CrawlingTask::clear_storage() {
  if (GetArenaNoVirtual() == NULL && storage_ != NULL) {
    delete storage_;
  }
  storage_ = NULL;
}
inline const ::spiderproto::Storage& CrawlingTask::storage() const {
  const ::spiderproto::Storage* p = storage_;
  // @@protoc_insertion_point(field_get:spiderproto.CrawlingTask.storage)
  return p != NULL ? *p : *reinterpret_cast<const ::spiderproto::Storage*>(
      &::spiderproto::_Storage_default_instance_);
}
inline ::spiderproto::Storage* CrawlingTask::release_storage() {
  // @@protoc_insertion_point(field_release:spiderproto.CrawlingTask.storage)
  
  ::spiderproto::Storage* temp = storage_;
  storage_ = NULL;
  return temp;
}
inline ::spiderproto::Storage* CrawlingTask::mutable_storage() {
  
  if (storage_ == NULL) {
    auto* p = CreateMaybeMessage<::spiderproto::Storage>(GetArenaNoVirtual());
    storage_ = p;
  }
  // @@protoc_insertion_point(field_mutable:spiderproto.CrawlingTask.storage)
  return storage_;
}
inline void CrawlingTask::set_allocated_storage(::spiderproto::Storage* storage) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete storage_;
  }
  if (storage) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      storage = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, storage, submessage_arena);
    }
    
  } else {
    
  }
  storage_ = storage;
  // @@protoc_insertion_point(field_set_allocated:spiderproto.CrawlingTask.storage)
}

// -------------------------------------------------------------------

// CrawledTask

// bytes taskid = 1;
inline void CrawledTask::clear_taskid() {
  taskid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CrawledTask::taskid() const {
  // @@protoc_insertion_point(field_get:spiderproto.CrawledTask.taskid)
  return taskid_.GetNoArena();
}
inline void CrawledTask::set_taskid(const ::std::string& value) {
  
  taskid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:spiderproto.CrawledTask.taskid)
}
#if LANG_CXX11
inline void CrawledTask::set_taskid(::std::string&& value) {
  
  taskid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:spiderproto.CrawledTask.taskid)
}
#endif
inline void CrawledTask::set_taskid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  taskid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:spiderproto.CrawledTask.taskid)
}
inline void CrawledTask::set_taskid(const void* value, size_t size) {
  
  taskid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:spiderproto.CrawledTask.taskid)
}
inline ::std::string* CrawledTask::mutable_taskid() {
  
  // @@protoc_insertion_point(field_mutable:spiderproto.CrawledTask.taskid)
  return taskid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CrawledTask::release_taskid() {
  // @@protoc_insertion_point(field_release:spiderproto.CrawledTask.taskid)
  
  return taskid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CrawledTask::set_allocated_taskid(::std::string* taskid) {
  if (taskid != NULL) {
    
  } else {
    
  }
  taskid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), taskid);
  // @@protoc_insertion_point(field_set_allocated:spiderproto.CrawledTask.taskid)
}

// bytes fetcher = 2;
inline void CrawledTask::clear_fetcher() {
  fetcher_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CrawledTask::fetcher() const {
  // @@protoc_insertion_point(field_get:spiderproto.CrawledTask.fetcher)
  return fetcher_.GetNoArena();
}
inline void CrawledTask::set_fetcher(const ::std::string& value) {
  
  fetcher_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:spiderproto.CrawledTask.fetcher)
}
#if LANG_CXX11
inline void CrawledTask::set_fetcher(::std::string&& value) {
  
  fetcher_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:spiderproto.CrawledTask.fetcher)
}
#endif
inline void CrawledTask::set_fetcher(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  fetcher_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:spiderproto.CrawledTask.fetcher)
}
inline void CrawledTask::set_fetcher(const void* value, size_t size) {
  
  fetcher_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:spiderproto.CrawledTask.fetcher)
}
inline ::std::string* CrawledTask::mutable_fetcher() {
  
  // @@protoc_insertion_point(field_mutable:spiderproto.CrawledTask.fetcher)
  return fetcher_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CrawledTask::release_fetcher() {
  // @@protoc_insertion_point(field_release:spiderproto.CrawledTask.fetcher)
  
  return fetcher_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CrawledTask::set_allocated_fetcher(::std::string* fetcher) {
  if (fetcher != NULL) {
    
  } else {
    
  }
  fetcher_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), fetcher);
  // @@protoc_insertion_point(field_set_allocated:spiderproto.CrawledTask.fetcher)
}

// .spiderproto.CrawlUrl crawl_url = 3;
inline bool CrawledTask::has_crawl_url() const {
  return this != internal_default_instance() && crawl_url_ != NULL;
}
inline void CrawledTask::clear_crawl_url() {
  if (GetArenaNoVirtual() == NULL && crawl_url_ != NULL) {
    delete crawl_url_;
  }
  crawl_url_ = NULL;
}
inline const ::spiderproto::CrawlUrl& CrawledTask::crawl_url() const {
  const ::spiderproto::CrawlUrl* p = crawl_url_;
  // @@protoc_insertion_point(field_get:spiderproto.CrawledTask.crawl_url)
  return p != NULL ? *p : *reinterpret_cast<const ::spiderproto::CrawlUrl*>(
      &::spiderproto::_CrawlUrl_default_instance_);
}
inline ::spiderproto::CrawlUrl* CrawledTask::release_crawl_url() {
  // @@protoc_insertion_point(field_release:spiderproto.CrawledTask.crawl_url)
  
  ::spiderproto::CrawlUrl* temp = crawl_url_;
  crawl_url_ = NULL;
  return temp;
}
inline ::spiderproto::CrawlUrl* CrawledTask::mutable_crawl_url() {
  
  if (crawl_url_ == NULL) {
    auto* p = CreateMaybeMessage<::spiderproto::CrawlUrl>(GetArenaNoVirtual());
    crawl_url_ = p;
  }
  // @@protoc_insertion_point(field_mutable:spiderproto.CrawledTask.crawl_url)
  return crawl_url_;
}
inline void CrawledTask::set_allocated_crawl_url(::spiderproto::CrawlUrl* crawl_url) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete crawl_url_;
  }
  if (crawl_url) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      crawl_url = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, crawl_url, submessage_arena);
    }
    
  } else {
    
  }
  crawl_url_ = crawl_url;
  // @@protoc_insertion_point(field_set_allocated:spiderproto.CrawledTask.crawl_url)
}

// int32 status = 4;
inline void CrawledTask::clear_status() {
  status_ = 0;
}
inline ::google::protobuf::int32 CrawledTask::status() const {
  // @@protoc_insertion_point(field_get:spiderproto.CrawledTask.status)
  return status_;
}
inline void CrawledTask::set_status(::google::protobuf::int32 value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:spiderproto.CrawledTask.status)
}

// repeated .spiderproto.CrawlUrl links = 5;
inline int CrawledTask::links_size() const {
  return links_.size();
}
inline void CrawledTask::clear_links() {
  links_.Clear();
}
inline ::spiderproto::CrawlUrl* CrawledTask::mutable_links(int index) {
  // @@protoc_insertion_point(field_mutable:spiderproto.CrawledTask.links)
  return links_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::spiderproto::CrawlUrl >*
CrawledTask::mutable_links() {
  // @@protoc_insertion_point(field_mutable_list:spiderproto.CrawledTask.links)
  return &links_;
}
inline const ::spiderproto::CrawlUrl& CrawledTask::links(int index) const {
  // @@protoc_insertion_point(field_get:spiderproto.CrawledTask.links)
  return links_.Get(index);
}
inline ::spiderproto::CrawlUrl* CrawledTask::add_links() {
  // @@protoc_insertion_point(field_add:spiderproto.CrawledTask.links)
  return links_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::spiderproto::CrawlUrl >&
CrawledTask::links() const {
  // @@protoc_insertion_point(field_list:spiderproto.CrawledTask.links)
  return links_;
}

// -------------------------------------------------------------------

// CrawlStats

// bytes taskid = 1;
inline void CrawlStats::clear_taskid() {
  taskid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CrawlStats::taskid() const {
  // @@protoc_insertion_point(field_get:spiderproto.CrawlStats.taskid)
  return taskid_.GetNoArena();
}
inline void CrawlStats::set_taskid(const ::std::string& value) {
  
  taskid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:spiderproto.CrawlStats.taskid)
}
#if LANG_CXX11
inline void CrawlStats::set_taskid(::std::string&& value) {
  
  taskid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:spiderproto.CrawlStats.taskid)
}
#endif
inline void CrawlStats::set_taskid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  taskid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:spiderproto.CrawlStats.taskid)
}
inline void CrawlStats::set_taskid(const void* value, size_t size) {
  
  taskid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:spiderproto.CrawlStats.taskid)
}
inline ::std::string* CrawlStats::mutable_taskid() {
  
  // @@protoc_insertion_point(field_mutable:spiderproto.CrawlStats.taskid)
  return taskid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CrawlStats::release_taskid() {
  // @@protoc_insertion_point(field_release:spiderproto.CrawlStats.taskid)
  
  return taskid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CrawlStats::set_allocated_taskid(::std::string* taskid) {
  if (taskid != NULL) {
    
  } else {
    
  }
  taskid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), taskid);
  // @@protoc_insertion_point(field_set_allocated:spiderproto.CrawlStats.taskid)
}

// bytes start_time = 2;
inline void CrawlStats::clear_start_time() {
  start_time_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CrawlStats::start_time() const {
  // @@protoc_insertion_point(field_get:spiderproto.CrawlStats.start_time)
  return start_time_.GetNoArena();
}
inline void CrawlStats::set_start_time(const ::std::string& value) {
  
  start_time_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:spiderproto.CrawlStats.start_time)
}
#if LANG_CXX11
inline void CrawlStats::set_start_time(::std::string&& value) {
  
  start_time_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:spiderproto.CrawlStats.start_time)
}
#endif
inline void CrawlStats::set_start_time(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  start_time_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:spiderproto.CrawlStats.start_time)
}
inline void CrawlStats::set_start_time(const void* value, size_t size) {
  
  start_time_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:spiderproto.CrawlStats.start_time)
}
inline ::std::string* CrawlStats::mutable_start_time() {
  
  // @@protoc_insertion_point(field_mutable:spiderproto.CrawlStats.start_time)
  return start_time_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CrawlStats::release_start_time() {
  // @@protoc_insertion_point(field_release:spiderproto.CrawlStats.start_time)
  
  return start_time_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CrawlStats::set_allocated_start_time(::std::string* start_time) {
  if (start_time != NULL) {
    
  } else {
    
  }
  start_time_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), start_time);
  // @@protoc_insertion_point(field_set_allocated:spiderproto.CrawlStats.start_time)
}

// bytes last_update = 3;
inline void CrawlStats::clear_last_update() {
  last_update_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CrawlStats::last_update() const {
  // @@protoc_insertion_point(field_get:spiderproto.CrawlStats.last_update)
  return last_update_.GetNoArena();
}
inline void CrawlStats::set_last_update(const ::std::string& value) {
  
  last_update_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:spiderproto.CrawlStats.last_update)
}
#if LANG_CXX11
inline void CrawlStats::set_last_update(::std::string&& value) {
  
  last_update_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:spiderproto.CrawlStats.last_update)
}
#endif
inline void CrawlStats::set_last_update(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  last_update_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:spiderproto.CrawlStats.last_update)
}
inline void CrawlStats::set_last_update(const void* value, size_t size) {
  
  last_update_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:spiderproto.CrawlStats.last_update)
}
inline ::std::string* CrawlStats::mutable_last_update() {
  
  // @@protoc_insertion_point(field_mutable:spiderproto.CrawlStats.last_update)
  return last_update_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CrawlStats::release_last_update() {
  // @@protoc_insertion_point(field_release:spiderproto.CrawlStats.last_update)
  
  return last_update_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CrawlStats::set_allocated_last_update(::std::string* last_update) {
  if (last_update != NULL) {
    
  } else {
    
  }
  last_update_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), last_update);
  // @@protoc_insertion_point(field_set_allocated:spiderproto.CrawlStats.last_update)
}

// int32 total_url = 4;
inline void CrawlStats::clear_total_url() {
  total_url_ = 0;
}
inline ::google::protobuf::int32 CrawlStats::total_url() const {
  // @@protoc_insertion_point(field_get:spiderproto.CrawlStats.total_url)
  return total_url_;
}
inline void CrawlStats::set_total_url(::google::protobuf::int32 value) {
  
  total_url_ = value;
  // @@protoc_insertion_point(field_set:spiderproto.CrawlStats.total_url)
}

// int32 success = 5;
inline void CrawlStats::clear_success() {
  success_ = 0;
}
inline ::google::protobuf::int32 CrawlStats::success() const {
  // @@protoc_insertion_point(field_get:spiderproto.CrawlStats.success)
  return success_;
}
inline void CrawlStats::set_success(::google::protobuf::int32 value) {
  
  success_ = value;
  // @@protoc_insertion_point(field_set:spiderproto.CrawlStats.success)
}

// int32 code40x = 6;
inline void CrawlStats::clear_code40x() {
  code40x_ = 0;
}
inline ::google::protobuf::int32 CrawlStats::code40x() const {
  // @@protoc_insertion_point(field_get:spiderproto.CrawlStats.code40x)
  return code40x_;
}
inline void CrawlStats::set_code40x(::google::protobuf::int32 value) {
  
  code40x_ = value;
  // @@protoc_insertion_point(field_set:spiderproto.CrawlStats.code40x)
}

// int32 code404 = 7;
inline void CrawlStats::clear_code404() {
  code404_ = 0;
}
inline ::google::protobuf::int32 CrawlStats::code404() const {
  // @@protoc_insertion_point(field_get:spiderproto.CrawlStats.code404)
  return code404_;
}
inline void CrawlStats::set_code404(::google::protobuf::int32 value) {
  
  code404_ = value;
  // @@protoc_insertion_point(field_set:spiderproto.CrawlStats.code404)
}

// int32 code50x = 8;
inline void CrawlStats::clear_code50x() {
  code50x_ = 0;
}
inline ::google::protobuf::int32 CrawlStats::code50x() const {
  // @@protoc_insertion_point(field_get:spiderproto.CrawlStats.code50x)
  return code50x_;
}
inline void CrawlStats::set_code50x(::google::protobuf::int32 value) {
  
  code50x_ = value;
  // @@protoc_insertion_point(field_set:spiderproto.CrawlStats.code50x)
}

// int32 codexxx = 9;
inline void CrawlStats::clear_codexxx() {
  codexxx_ = 0;
}
inline ::google::protobuf::int32 CrawlStats::codexxx() const {
  // @@protoc_insertion_point(field_get:spiderproto.CrawlStats.codexxx)
  return codexxx_;
}
inline void CrawlStats::set_codexxx(::google::protobuf::int32 value) {
  
  codexxx_ = value;
  // @@protoc_insertion_point(field_set:spiderproto.CrawlStats.codexxx)
}

// int32 links = 10;
inline void CrawlStats::clear_links() {
  links_ = 0;
}
inline ::google::protobuf::int32 CrawlStats::links() const {
  // @@protoc_insertion_point(field_get:spiderproto.CrawlStats.links)
  return links_;
}
inline void CrawlStats::set_links(::google::protobuf::int32 value) {
  
  links_ = value;
  // @@protoc_insertion_point(field_set:spiderproto.CrawlStats.links)
}

// -------------------------------------------------------------------

// TaskResponse

// bytes taskid = 1;
inline void TaskResponse::clear_taskid() {
  taskid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TaskResponse::taskid() const {
  // @@protoc_insertion_point(field_get:spiderproto.TaskResponse.taskid)
  return taskid_.GetNoArena();
}
inline void TaskResponse::set_taskid(const ::std::string& value) {
  
  taskid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:spiderproto.TaskResponse.taskid)
}
#if LANG_CXX11
inline void TaskResponse::set_taskid(::std::string&& value) {
  
  taskid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:spiderproto.TaskResponse.taskid)
}
#endif
inline void TaskResponse::set_taskid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  taskid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:spiderproto.TaskResponse.taskid)
}
inline void TaskResponse::set_taskid(const void* value, size_t size) {
  
  taskid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:spiderproto.TaskResponse.taskid)
}
inline ::std::string* TaskResponse::mutable_taskid() {
  
  // @@protoc_insertion_point(field_mutable:spiderproto.TaskResponse.taskid)
  return taskid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TaskResponse::release_taskid() {
  // @@protoc_insertion_point(field_release:spiderproto.TaskResponse.taskid)
  
  return taskid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TaskResponse::set_allocated_taskid(::std::string* taskid) {
  if (taskid != NULL) {
    
  } else {
    
  }
  taskid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), taskid);
  // @@protoc_insertion_point(field_set_allocated:spiderproto.TaskResponse.taskid)
}

// int32 code = 2;
inline void TaskResponse::clear_code() {
  code_ = 0;
}
inline ::google::protobuf::int32 TaskResponse::code() const {
  // @@protoc_insertion_point(field_get:spiderproto.TaskResponse.code)
  return code_;
}
inline void TaskResponse::set_code(::google::protobuf::int32 value) {
  
  code_ = value;
  // @@protoc_insertion_point(field_set:spiderproto.TaskResponse.code)
}

// bytes msg = 3;
inline void TaskResponse::clear_msg() {
  msg_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TaskResponse::msg() const {
  // @@protoc_insertion_point(field_get:spiderproto.TaskResponse.msg)
  return msg_.GetNoArena();
}
inline void TaskResponse::set_msg(const ::std::string& value) {
  
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:spiderproto.TaskResponse.msg)
}
#if LANG_CXX11
inline void TaskResponse::set_msg(::std::string&& value) {
  
  msg_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:spiderproto.TaskResponse.msg)
}
#endif
inline void TaskResponse::set_msg(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:spiderproto.TaskResponse.msg)
}
inline void TaskResponse::set_msg(const void* value, size_t size) {
  
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:spiderproto.TaskResponse.msg)
}
inline ::std::string* TaskResponse::mutable_msg() {
  
  // @@protoc_insertion_point(field_mutable:spiderproto.TaskResponse.msg)
  return msg_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TaskResponse::release_msg() {
  // @@protoc_insertion_point(field_release:spiderproto.TaskResponse.msg)
  
  return msg_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TaskResponse::set_allocated_msg(::std::string* msg) {
  if (msg != NULL) {
    
  } else {
    
  }
  msg_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), msg);
  // @@protoc_insertion_point(field_set_allocated:spiderproto.TaskResponse.msg)
}

// -------------------------------------------------------------------

// Empty

// -------------------------------------------------------------------

// Fetcher

// bytes name = 1;
inline void Fetcher::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Fetcher::name() const {
  // @@protoc_insertion_point(field_get:spiderproto.Fetcher.name)
  return name_.GetNoArena();
}
inline void Fetcher::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:spiderproto.Fetcher.name)
}
#if LANG_CXX11
inline void Fetcher::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:spiderproto.Fetcher.name)
}
#endif
inline void Fetcher::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:spiderproto.Fetcher.name)
}
inline void Fetcher::set_name(const void* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:spiderproto.Fetcher.name)
}
inline ::std::string* Fetcher::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:spiderproto.Fetcher.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Fetcher::release_name() {
  // @@protoc_insertion_point(field_release:spiderproto.Fetcher.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Fetcher::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:spiderproto.Fetcher.name)
}

// bytes addr = 2;
inline void Fetcher::clear_addr() {
  addr_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Fetcher::addr() const {
  // @@protoc_insertion_point(field_get:spiderproto.Fetcher.addr)
  return addr_.GetNoArena();
}
inline void Fetcher::set_addr(const ::std::string& value) {
  
  addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:spiderproto.Fetcher.addr)
}
#if LANG_CXX11
inline void Fetcher::set_addr(::std::string&& value) {
  
  addr_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:spiderproto.Fetcher.addr)
}
#endif
inline void Fetcher::set_addr(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:spiderproto.Fetcher.addr)
}
inline void Fetcher::set_addr(const void* value, size_t size) {
  
  addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:spiderproto.Fetcher.addr)
}
inline ::std::string* Fetcher::mutable_addr() {
  
  // @@protoc_insertion_point(field_mutable:spiderproto.Fetcher.addr)
  return addr_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Fetcher::release_addr() {
  // @@protoc_insertion_point(field_release:spiderproto.Fetcher.addr)
  
  return addr_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Fetcher::set_allocated_addr(::std::string* addr) {
  if (addr != NULL) {
    
  } else {
    
  }
  addr_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), addr);
  // @@protoc_insertion_point(field_set_allocated:spiderproto.Fetcher.addr)
}

// -------------------------------------------------------------------

// Segment

// bytes word = 1;
inline void Segment::clear_word() {
  word_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Segment::word() const {
  // @@protoc_insertion_point(field_get:spiderproto.Segment.word)
  return word_.GetNoArena();
}
inline void Segment::set_word(const ::std::string& value) {
  
  word_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:spiderproto.Segment.word)
}
#if LANG_CXX11
inline void Segment::set_word(::std::string&& value) {
  
  word_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:spiderproto.Segment.word)
}
#endif
inline void Segment::set_word(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  word_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:spiderproto.Segment.word)
}
inline void Segment::set_word(const void* value, size_t size) {
  
  word_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:spiderproto.Segment.word)
}
inline ::std::string* Segment::mutable_word() {
  
  // @@protoc_insertion_point(field_mutable:spiderproto.Segment.word)
  return word_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Segment::release_word() {
  // @@protoc_insertion_point(field_release:spiderproto.Segment.word)
  
  return word_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Segment::set_allocated_word(::std::string* word) {
  if (word != NULL) {
    
  } else {
    
  }
  word_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), word);
  // @@protoc_insertion_point(field_set_allocated:spiderproto.Segment.word)
}

// int32 score = 2;
inline void Segment::clear_score() {
  score_ = 0;
}
inline ::google::protobuf::int32 Segment::score() const {
  // @@protoc_insertion_point(field_get:spiderproto.Segment.score)
  return score_;
}
inline void Segment::set_score(::google::protobuf::int32 value) {
  
  score_ = value;
  // @@protoc_insertion_point(field_set:spiderproto.Segment.score)
}

// -------------------------------------------------------------------

// SegmentList

// repeated .spiderproto.Segment segments = 1;
inline int SegmentList::segments_size() const {
  return segments_.size();
}
inline void SegmentList::clear_segments() {
  segments_.Clear();
}
inline ::spiderproto::Segment* SegmentList::mutable_segments(int index) {
  // @@protoc_insertion_point(field_mutable:spiderproto.SegmentList.segments)
  return segments_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::spiderproto::Segment >*
SegmentList::mutable_segments() {
  // @@protoc_insertion_point(field_mutable_list:spiderproto.SegmentList.segments)
  return &segments_;
}
inline const ::spiderproto::Segment& SegmentList::segments(int index) const {
  // @@protoc_insertion_point(field_get:spiderproto.SegmentList.segments)
  return segments_.Get(index);
}
inline ::spiderproto::Segment* SegmentList::add_segments() {
  // @@protoc_insertion_point(field_add:spiderproto.SegmentList.segments)
  return segments_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::spiderproto::Segment >&
SegmentList::segments() const {
  // @@protoc_insertion_point(field_list:spiderproto.SegmentList.segments)
  return segments_;
}

// -------------------------------------------------------------------

// CrawlDoc

// bytes taskid = 1;
inline void CrawlDoc::clear_taskid() {
  taskid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CrawlDoc::taskid() const {
  // @@protoc_insertion_point(field_get:spiderproto.CrawlDoc.taskid)
  return taskid_.GetNoArena();
}
inline void CrawlDoc::set_taskid(const ::std::string& value) {
  
  taskid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:spiderproto.CrawlDoc.taskid)
}
#if LANG_CXX11
inline void CrawlDoc::set_taskid(::std::string&& value) {
  
  taskid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:spiderproto.CrawlDoc.taskid)
}
#endif
inline void CrawlDoc::set_taskid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  taskid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:spiderproto.CrawlDoc.taskid)
}
inline void CrawlDoc::set_taskid(const void* value, size_t size) {
  
  taskid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:spiderproto.CrawlDoc.taskid)
}
inline ::std::string* CrawlDoc::mutable_taskid() {
  
  // @@protoc_insertion_point(field_mutable:spiderproto.CrawlDoc.taskid)
  return taskid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CrawlDoc::release_taskid() {
  // @@protoc_insertion_point(field_release:spiderproto.CrawlDoc.taskid)
  
  return taskid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CrawlDoc::set_allocated_taskid(::std::string* taskid) {
  if (taskid != NULL) {
    
  } else {
    
  }
  taskid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), taskid);
  // @@protoc_insertion_point(field_set_allocated:spiderproto.CrawlDoc.taskid)
}

// bytes url = 2;
inline void CrawlDoc::clear_url() {
  url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CrawlDoc::url() const {
  // @@protoc_insertion_point(field_get:spiderproto.CrawlDoc.url)
  return url_.GetNoArena();
}
inline void CrawlDoc::set_url(const ::std::string& value) {
  
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:spiderproto.CrawlDoc.url)
}
#if LANG_CXX11
inline void CrawlDoc::set_url(::std::string&& value) {
  
  url_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:spiderproto.CrawlDoc.url)
}
#endif
inline void CrawlDoc::set_url(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:spiderproto.CrawlDoc.url)
}
inline void CrawlDoc::set_url(const void* value, size_t size) {
  
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:spiderproto.CrawlDoc.url)
}
inline ::std::string* CrawlDoc::mutable_url() {
  
  // @@protoc_insertion_point(field_mutable:spiderproto.CrawlDoc.url)
  return url_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CrawlDoc::release_url() {
  // @@protoc_insertion_point(field_release:spiderproto.CrawlDoc.url)
  
  return url_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CrawlDoc::set_allocated_url(::std::string* url) {
  if (url != NULL) {
    
  } else {
    
  }
  url_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), url);
  // @@protoc_insertion_point(field_set_allocated:spiderproto.CrawlDoc.url)
}

// int32 status = 3;
inline void CrawlDoc::clear_status() {
  status_ = 0;
}
inline ::google::protobuf::int32 CrawlDoc::status() const {
  // @@protoc_insertion_point(field_get:spiderproto.CrawlDoc.status)
  return status_;
}
inline void CrawlDoc::set_status(::google::protobuf::int32 value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:spiderproto.CrawlDoc.status)
}

// bytes content = 4;
inline void CrawlDoc::clear_content() {
  content_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CrawlDoc::content() const {
  // @@protoc_insertion_point(field_get:spiderproto.CrawlDoc.content)
  return content_.GetNoArena();
}
inline void CrawlDoc::set_content(const ::std::string& value) {
  
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:spiderproto.CrawlDoc.content)
}
#if LANG_CXX11
inline void CrawlDoc::set_content(::std::string&& value) {
  
  content_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:spiderproto.CrawlDoc.content)
}
#endif
inline void CrawlDoc::set_content(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:spiderproto.CrawlDoc.content)
}
inline void CrawlDoc::set_content(const void* value, size_t size) {
  
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:spiderproto.CrawlDoc.content)
}
inline ::std::string* CrawlDoc::mutable_content() {
  
  // @@protoc_insertion_point(field_mutable:spiderproto.CrawlDoc.content)
  return content_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CrawlDoc::release_content() {
  // @@protoc_insertion_point(field_release:spiderproto.CrawlDoc.content)
  
  return content_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CrawlDoc::set_allocated_content(::std::string* content) {
  if (content != NULL) {
    
  } else {
    
  }
  content_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), content);
  // @@protoc_insertion_point(field_set_allocated:spiderproto.CrawlDoc.content)
}

// .spiderproto.Storage storage = 5;
inline bool CrawlDoc::has_storage() const {
  return this != internal_default_instance() && storage_ != NULL;
}
inline void CrawlDoc::clear_storage() {
  if (GetArenaNoVirtual() == NULL && storage_ != NULL) {
    delete storage_;
  }
  storage_ = NULL;
}
inline const ::spiderproto::Storage& CrawlDoc::storage() const {
  const ::spiderproto::Storage* p = storage_;
  // @@protoc_insertion_point(field_get:spiderproto.CrawlDoc.storage)
  return p != NULL ? *p : *reinterpret_cast<const ::spiderproto::Storage*>(
      &::spiderproto::_Storage_default_instance_);
}
inline ::spiderproto::Storage* CrawlDoc::release_storage() {
  // @@protoc_insertion_point(field_release:spiderproto.CrawlDoc.storage)
  
  ::spiderproto::Storage* temp = storage_;
  storage_ = NULL;
  return temp;
}
inline ::spiderproto::Storage* CrawlDoc::mutable_storage() {
  
  if (storage_ == NULL) {
    auto* p = CreateMaybeMessage<::spiderproto::Storage>(GetArenaNoVirtual());
    storage_ = p;
  }
  // @@protoc_insertion_point(field_mutable:spiderproto.CrawlDoc.storage)
  return storage_;
}
inline void CrawlDoc::set_allocated_storage(::spiderproto::Storage* storage) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete storage_;
  }
  if (storage) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      storage = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, storage, submessage_arena);
    }
    
  } else {
    
  }
  storage_ = storage;
  // @@protoc_insertion_point(field_set_allocated:spiderproto.CrawlDoc.storage)
}

// .spiderproto.SegmentList segment_list = 6;
inline bool CrawlDoc::has_segment_list() const {
  return this != internal_default_instance() && segment_list_ != NULL;
}
inline void CrawlDoc::clear_segment_list() {
  if (GetArenaNoVirtual() == NULL && segment_list_ != NULL) {
    delete segment_list_;
  }
  segment_list_ = NULL;
}
inline const ::spiderproto::SegmentList& CrawlDoc::segment_list() const {
  const ::spiderproto::SegmentList* p = segment_list_;
  // @@protoc_insertion_point(field_get:spiderproto.CrawlDoc.segment_list)
  return p != NULL ? *p : *reinterpret_cast<const ::spiderproto::SegmentList*>(
      &::spiderproto::_SegmentList_default_instance_);
}
inline ::spiderproto::SegmentList* CrawlDoc::release_segment_list() {
  // @@protoc_insertion_point(field_release:spiderproto.CrawlDoc.segment_list)
  
  ::spiderproto::SegmentList* temp = segment_list_;
  segment_list_ = NULL;
  return temp;
}
inline ::spiderproto::SegmentList* CrawlDoc::mutable_segment_list() {
  
  if (segment_list_ == NULL) {
    auto* p = CreateMaybeMessage<::spiderproto::SegmentList>(GetArenaNoVirtual());
    segment_list_ = p;
  }
  // @@protoc_insertion_point(field_mutable:spiderproto.CrawlDoc.segment_list)
  return segment_list_;
}
inline void CrawlDoc::set_allocated_segment_list(::spiderproto::SegmentList* segment_list) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete segment_list_;
  }
  if (segment_list) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      segment_list = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, segment_list, submessage_arena);
    }
    
  } else {
    
  }
  segment_list_ = segment_list;
  // @@protoc_insertion_point(field_set_allocated:spiderproto.CrawlDoc.segment_list)
}

// -------------------------------------------------------------------

// CrawlDocs

// bytes taskid = 1;
inline void CrawlDocs::clear_taskid() {
  taskid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CrawlDocs::taskid() const {
  // @@protoc_insertion_point(field_get:spiderproto.CrawlDocs.taskid)
  return taskid_.GetNoArena();
}
inline void CrawlDocs::set_taskid(const ::std::string& value) {
  
  taskid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:spiderproto.CrawlDocs.taskid)
}
#if LANG_CXX11
inline void CrawlDocs::set_taskid(::std::string&& value) {
  
  taskid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:spiderproto.CrawlDocs.taskid)
}
#endif
inline void CrawlDocs::set_taskid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  taskid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:spiderproto.CrawlDocs.taskid)
}
inline void CrawlDocs::set_taskid(const void* value, size_t size) {
  
  taskid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:spiderproto.CrawlDocs.taskid)
}
inline ::std::string* CrawlDocs::mutable_taskid() {
  
  // @@protoc_insertion_point(field_mutable:spiderproto.CrawlDocs.taskid)
  return taskid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CrawlDocs::release_taskid() {
  // @@protoc_insertion_point(field_release:spiderproto.CrawlDocs.taskid)
  
  return taskid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CrawlDocs::set_allocated_taskid(::std::string* taskid) {
  if (taskid != NULL) {
    
  } else {
    
  }
  taskid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), taskid);
  // @@protoc_insertion_point(field_set_allocated:spiderproto.CrawlDocs.taskid)
}

// repeated .spiderproto.CrawlDoc docs = 2;
inline int CrawlDocs::docs_size() const {
  return docs_.size();
}
inline void CrawlDocs::clear_docs() {
  docs_.Clear();
}
inline ::spiderproto::CrawlDoc* CrawlDocs::mutable_docs(int index) {
  // @@protoc_insertion_point(field_mutable:spiderproto.CrawlDocs.docs)
  return docs_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::spiderproto::CrawlDoc >*
CrawlDocs::mutable_docs() {
  // @@protoc_insertion_point(field_mutable_list:spiderproto.CrawlDocs.docs)
  return &docs_;
}
inline const ::spiderproto::CrawlDoc& CrawlDocs::docs(int index) const {
  // @@protoc_insertion_point(field_get:spiderproto.CrawlDocs.docs)
  return docs_.Get(index);
}
inline ::spiderproto::CrawlDoc* CrawlDocs::add_docs() {
  // @@protoc_insertion_point(field_add:spiderproto.CrawlDocs.docs)
  return docs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::spiderproto::CrawlDoc >&
CrawlDocs::docs() const {
  // @@protoc_insertion_point(field_list:spiderproto.CrawlDocs.docs)
  return docs_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace spiderproto

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::spiderproto::Storage_StorageType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::spiderproto::Storage_StorageType>() {
  return ::spiderproto::Storage_StorageType_descriptor();
}
template <> struct is_proto_enum< ::spiderproto::UrlLevel> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::spiderproto::UrlLevel>() {
  return ::spiderproto::UrlLevel_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // PROTOBUF_INCLUDED_spider_2eproto
