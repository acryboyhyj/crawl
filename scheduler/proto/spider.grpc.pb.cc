// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: spider.proto

#include "spider.grpc.pb.h"
#include "spider.pb.h"

#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/channel_interface.h>
#include <grpcpp/impl/codegen/client_unary_call.h>
#include <grpcpp/impl/codegen/method_handler_impl.h>
#include <grpcpp/impl/codegen/rpc_service_method.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/sync_stream.h>
namespace spiderproto {

static const char* Schedule_method_names[] = {
    "/spiderproto.Schedule/add_task", "/spiderproto.Schedule/add_fetcher",
    "/spiderproto.Schedule/add_crawledtask",
};

std::unique_ptr<Schedule::Stub> Schedule::NewStub(
    const std::shared_ptr<::grpc::ChannelInterface>& channel,
    const ::grpc::StubOptions& options) {
    (void)options;
    std::unique_ptr<Schedule::Stub> stub(new Schedule::Stub(channel));
    return stub;
}

Schedule::Stub::Stub(const std::shared_ptr<::grpc::ChannelInterface>& channel)
    : channel_(channel),
      rpcmethod_add_task_(Schedule_method_names[0],
                          ::grpc::internal::RpcMethod::NORMAL_RPC, channel),
      rpcmethod_add_fetcher_(Schedule_method_names[1],
                             ::grpc::internal::RpcMethod::NORMAL_RPC, channel),
      rpcmethod_add_crawledtask_(Schedule_method_names[2],
                                 ::grpc::internal::RpcMethod::NORMAL_RPC,
                                 channel) {}

::grpc::Status Schedule::Stub::add_task(::grpc::ClientContext* context,
                                        const ::spiderproto::BasicTask& request,
                                        ::spiderproto::TaskResponse* response) {
    return ::grpc::internal::BlockingUnaryCall(
        channel_.get(), rpcmethod_add_task_, context, request, response);
}

::grpc::ClientAsyncResponseReader<::spiderproto::TaskResponse>*
Schedule::Stub::Asyncadd_taskRaw(::grpc::ClientContext* context,
                                 const ::spiderproto::BasicTask& request,
                                 ::grpc::CompletionQueue* cq) {
    return ::grpc::internal::ClientAsyncResponseReaderFactory<
        ::spiderproto::TaskResponse>::Create(channel_.get(), cq,
                                             rpcmethod_add_task_, context,
                                             request, true);
}

::grpc::ClientAsyncResponseReader<::spiderproto::TaskResponse>*
Schedule::Stub::PrepareAsyncadd_taskRaw(::grpc::ClientContext* context,
                                        const ::spiderproto::BasicTask& request,
                                        ::grpc::CompletionQueue* cq) {
    return ::grpc::internal::ClientAsyncResponseReaderFactory<
        ::spiderproto::TaskResponse>::Create(channel_.get(), cq,
                                             rpcmethod_add_task_, context,
                                             request, false);
}

::grpc::Status Schedule::Stub::add_fetcher(
    ::grpc::ClientContext* context, const ::spiderproto::Fetcher& request,
    ::spiderproto::TaskResponse* response) {
    return ::grpc::internal::BlockingUnaryCall(
        channel_.get(), rpcmethod_add_fetcher_, context, request, response);
}

::grpc::ClientAsyncResponseReader<::spiderproto::TaskResponse>*
Schedule::Stub::Asyncadd_fetcherRaw(::grpc::ClientContext* context,
                                    const ::spiderproto::Fetcher& request,
                                    ::grpc::CompletionQueue* cq) {
    return ::grpc::internal::ClientAsyncResponseReaderFactory<
        ::spiderproto::TaskResponse>::Create(channel_.get(), cq,
                                             rpcmethod_add_fetcher_, context,
                                             request, true);
}

::grpc::ClientAsyncResponseReader<::spiderproto::TaskResponse>*
Schedule::Stub::PrepareAsyncadd_fetcherRaw(
    ::grpc::ClientContext* context, const ::spiderproto::Fetcher& request,
    ::grpc::CompletionQueue* cq) {
    return ::grpc::internal::ClientAsyncResponseReaderFactory<
        ::spiderproto::TaskResponse>::Create(channel_.get(), cq,
                                             rpcmethod_add_fetcher_, context,
                                             request, false);
}

::grpc::Status Schedule::Stub::add_crawledtask(
    ::grpc::ClientContext* context, const ::spiderproto::CrawledTask& request,
    ::spiderproto::TaskResponse* response) {
    return ::grpc::internal::BlockingUnaryCall(
        channel_.get(), rpcmethod_add_crawledtask_, context, request, response);
}

::grpc::ClientAsyncResponseReader<::spiderproto::TaskResponse>*
Schedule::Stub::Asyncadd_crawledtaskRaw(
    ::grpc::ClientContext* context, const ::spiderproto::CrawledTask& request,
    ::grpc::CompletionQueue* cq) {
    return ::grpc::internal::ClientAsyncResponseReaderFactory<
        ::spiderproto::TaskResponse>::Create(channel_.get(), cq,
                                             rpcmethod_add_crawledtask_,
                                             context, request, true);
}

::grpc::ClientAsyncResponseReader<::spiderproto::TaskResponse>*
Schedule::Stub::PrepareAsyncadd_crawledtaskRaw(
    ::grpc::ClientContext* context, const ::spiderproto::CrawledTask& request,
    ::grpc::CompletionQueue* cq) {
    return ::grpc::internal::ClientAsyncResponseReaderFactory<
        ::spiderproto::TaskResponse>::Create(channel_.get(), cq,
                                             rpcmethod_add_crawledtask_,
                                             context, request, false);
}

Schedule::Service::Service() {
    AddMethod(new ::grpc::internal::RpcServiceMethod(
        Schedule_method_names[0], ::grpc::internal::RpcMethod::NORMAL_RPC,
        new ::grpc::internal::RpcMethodHandler<Schedule::Service,
                                               ::spiderproto::BasicTask,
                                               ::spiderproto::TaskResponse>(
            std::mem_fn(&Schedule::Service::add_task), this)));
    AddMethod(new ::grpc::internal::RpcServiceMethod(
        Schedule_method_names[1], ::grpc::internal::RpcMethod::NORMAL_RPC,
        new ::grpc::internal::RpcMethodHandler<Schedule::Service,
                                               ::spiderproto::Fetcher,
                                               ::spiderproto::TaskResponse>(
            std::mem_fn(&Schedule::Service::add_fetcher), this)));
    AddMethod(new ::grpc::internal::RpcServiceMethod(
        Schedule_method_names[2], ::grpc::internal::RpcMethod::NORMAL_RPC,
        new ::grpc::internal::RpcMethodHandler<Schedule::Service,
                                               ::spiderproto::CrawledTask,
                                               ::spiderproto::TaskResponse>(
            std::mem_fn(&Schedule::Service::add_crawledtask), this)));
}

Schedule::Service::~Service() {}

::grpc::Status Schedule::Service::add_task(
    ::grpc::ServerContext* context, const ::spiderproto::BasicTask* request,
    ::spiderproto::TaskResponse* response) {
    (void)context;
    (void)request;
    (void)response;
    return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status Schedule::Service::add_fetcher(
    ::grpc::ServerContext* context, const ::spiderproto::Fetcher* request,
    ::spiderproto::TaskResponse* response) {
    (void)context;
    (void)request;
    (void)response;
    return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status Schedule::Service::add_crawledtask(
    ::grpc::ServerContext* context, const ::spiderproto::CrawledTask* request,
    ::spiderproto::TaskResponse* response) {
    (void)context;
    (void)request;
    (void)response;
    return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

static const char* Fetch_method_names[] = {
    "/spiderproto.Fetch/add_crawlingtask",
};

std::unique_ptr<Fetch::Stub> Fetch::NewStub(
    const std::shared_ptr<::grpc::ChannelInterface>& channel,
    const ::grpc::StubOptions& options) {
    (void)options;
    std::unique_ptr<Fetch::Stub> stub(new Fetch::Stub(channel));
    return stub;
}

Fetch::Stub::Stub(const std::shared_ptr<::grpc::ChannelInterface>& channel)
    : channel_(channel),
      rpcmethod_add_crawlingtask_(Fetch_method_names[0],
                                  ::grpc::internal::RpcMethod::NORMAL_RPC,
                                  channel) {}

::grpc::Status Fetch::Stub::add_crawlingtask(
    ::grpc::ClientContext* context, const ::spiderproto::CrawlingTask& request,
    ::spiderproto::TaskResponse* response) {
    return ::grpc::internal::BlockingUnaryCall(channel_.get(),
                                               rpcmethod_add_crawlingtask_,
                                               context, request, response);
}

::grpc::ClientAsyncResponseReader<::spiderproto::TaskResponse>*
Fetch::Stub::Asyncadd_crawlingtaskRaw(
    ::grpc::ClientContext* context, const ::spiderproto::CrawlingTask& request,
    ::grpc::CompletionQueue* cq) {
    return ::grpc::internal::ClientAsyncResponseReaderFactory<
        ::spiderproto::TaskResponse>::Create(channel_.get(), cq,
                                             rpcmethod_add_crawlingtask_,
                                             context, request, true);
}

::grpc::ClientAsyncResponseReader<::spiderproto::TaskResponse>*
Fetch::Stub::PrepareAsyncadd_crawlingtaskRaw(
    ::grpc::ClientContext* context, const ::spiderproto::CrawlingTask& request,
    ::grpc::CompletionQueue* cq) {
    return ::grpc::internal::ClientAsyncResponseReaderFactory<
        ::spiderproto::TaskResponse>::Create(channel_.get(), cq,
                                             rpcmethod_add_crawlingtask_,
                                             context, request, false);
}

Fetch::Service::Service() {
    AddMethod(new ::grpc::internal::RpcServiceMethod(
        Fetch_method_names[0], ::grpc::internal::RpcMethod::NORMAL_RPC,
        new ::grpc::internal::RpcMethodHandler<Fetch::Service,
                                               ::spiderproto::CrawlingTask,
                                               ::spiderproto::TaskResponse>(
            std::mem_fn(&Fetch::Service::add_crawlingtask), this)));
}

Fetch::Service::~Service() {}

::grpc::Status Fetch::Service::add_crawlingtask(
    ::grpc::ServerContext* context, const ::spiderproto::CrawlingTask* request,
    ::spiderproto::TaskResponse* response) {
    (void)context;
    (void)request;
    (void)response;
    return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

static const char* Handle_method_names[] = {
    "/spiderproto.Handle/add_crawldoc",
};

std::unique_ptr<Handle::Stub> Handle::NewStub(
    const std::shared_ptr<::grpc::ChannelInterface>& channel,
    const ::grpc::StubOptions& options) {
    (void)options;
    std::unique_ptr<Handle::Stub> stub(new Handle::Stub(channel));
    return stub;
}

Handle::Stub::Stub(const std::shared_ptr<::grpc::ChannelInterface>& channel)
    : channel_(channel),
      rpcmethod_add_crawldoc_(Handle_method_names[0],
                              ::grpc::internal::RpcMethod::NORMAL_RPC,
                              channel) {}

::grpc::Status Handle::Stub::add_crawldoc(
    ::grpc::ClientContext* context, const ::spiderproto::CrawlDoc& request,
    ::spiderproto::TaskResponse* response) {
    return ::grpc::internal::BlockingUnaryCall(
        channel_.get(), rpcmethod_add_crawldoc_, context, request, response);
}

::grpc::ClientAsyncResponseReader<::spiderproto::TaskResponse>*
Handle::Stub::Asyncadd_crawldocRaw(::grpc::ClientContext* context,
                                   const ::spiderproto::CrawlDoc& request,
                                   ::grpc::CompletionQueue* cq) {
    return ::grpc::internal::ClientAsyncResponseReaderFactory<
        ::spiderproto::TaskResponse>::Create(channel_.get(), cq,
                                             rpcmethod_add_crawldoc_, context,
                                             request, true);
}

::grpc::ClientAsyncResponseReader<::spiderproto::TaskResponse>*
Handle::Stub::PrepareAsyncadd_crawldocRaw(
    ::grpc::ClientContext* context, const ::spiderproto::CrawlDoc& request,
    ::grpc::CompletionQueue* cq) {
    return ::grpc::internal::ClientAsyncResponseReaderFactory<
        ::spiderproto::TaskResponse>::Create(channel_.get(), cq,
                                             rpcmethod_add_crawldoc_, context,
                                             request, false);
}

Handle::Service::Service() {
    AddMethod(new ::grpc::internal::RpcServiceMethod(
        Handle_method_names[0], ::grpc::internal::RpcMethod::NORMAL_RPC,
        new ::grpc::internal::RpcMethodHandler<Handle::Service,
                                               ::spiderproto::CrawlDoc,
                                               ::spiderproto::TaskResponse>(
            std::mem_fn(&Handle::Service::add_crawldoc), this)));
}

Handle::Service::~Service() {}

::grpc::Status Handle::Service::add_crawldoc(
    ::grpc::ServerContext* context, const ::spiderproto::CrawlDoc* request,
    ::spiderproto::TaskResponse* response) {
    (void)context;
    (void)request;
    (void)response;
    return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

}  // namespace spiderproto
